<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>  What does Rust&apos;s “unsafe” mean? |  Huon on the internet</title>

  <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Atom feed">
  <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RSS feed">
  
  <link rel="canonical" href="https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/">

  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  

  
  <meta name="description" content="Exploring Rust&apos;s escape hatch for writing low-level code that the powerful type system of Rust cannot guarantee to be safe.
" />

  
  <meta name="twitter:card" content="summary" />
  
  <meta name="twitter:site" content="@huon_w" />
  <meta name="twitter:title" content="What does Rust&apos;s “unsafe” mean?" />
  <meta name="twitter:description" content="Exploring Rust&apos;s escape hatch for writing low-level code that the powerful type system of Rust cannot guarantee to be safe.
" />
  <meta name="twitter:url" content="https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/">

  <!-- facebook -->
  <meta property="og:url" content="https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/" />
  <meta property="og:title" content="What does Rust&apos;s “unsafe” mean?" />
  <meta property="og:description" content="Exploring Rust&apos;s escape hatch for writing low-level code that the powerful type system of Rust cannot guarantee to be safe.
" />
  
  <meta property="og:type" content="article" />
  
  
  
  <style>
    /*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}html{line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0;font-family:system-ui, -apple-system,'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type='button'],[type='reset'],[type='submit'],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}


    
      /* Borrowed from mojombo: https://github.com/mojombo/mojombo.github.com/blob/master/css/syntax.css */

.lineno { width: 2em; text-align:right; }
.highlight pre {
  white-space: pre;
}
.highlight .c { color: #777; font-style: italic; } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */


html {
    min-height:100%;
}

* {
  margin: 0;
}
* + * {
  margin-top: 0.75em;
}


body {
  padding:0px;
    counter-reset: footnotes;
    counter-reset: figure;
    margin:0px;
    font-size: 18px;
    background: white;
    color: #101010;

    font-variant: common-ligatures;
    -moz-font-feature-settings: "kern" on;
    -webkit-font-feature-settings: "kern" on;
    font-feature-settings: "kern" on;
}

#wrapper {
    margin: 0 auto;
    max-width: 630px;
    padding: 0.75em 15px;
    width: 100%;
    position:relative;
}

#no-ai {
    text-align: center;
    font-size: small;
}

.lazily-filled {
  position: relative;
}
.lazily-filled > * {
  z-index: 0;
}
.lazily-filled::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgb(229, 236, 246);
  z-index: 1;
}
.lazily-filled::after {
  position: absolute;
  top: 50%;
  left: 50%;
  content: "";
  display: block;
  width: 128px;
  height: 128px;
  margin-left: -64px;
  margin-top: -64px;
  border-radius: 50%;
  border: 12px solid;
  border-color: white transparent;
  animation: spinner 5s linear;
  /* eventually stop animating when it's hidden */
  animation-iteration-count: 10;
  z-index: 2;
}
.lazily-filled::before, .lazily-filled::after {
  opacity: 0;
  transition: all 0.5s ease;
  pointer-events: none;
}
.lazily-filled:empty::before, .lazily-filled:empty::after {
  opacity: 1;
  animation-iteration-count: infinite;
  visibility: visible;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.plotly-plot * + * {
  margin-top: 0;
}

/* wonky safari */
.plotly text[style*="white-space: pre"] {
  white-space: nowrap !important;
}


/* lists */
li + li {
  margin-top: 0.5em;
}
ul, ol {
  padding-left: 1.5em;
}

table {
  margin-left: auto;
  margin-right: auto;
  border-collapse: collapse;
  text-align: left;
}

/* ensure tables don't make the whole page scroll, NB. requires manual <div class="table-wrapper" markdown="1">...</div> due to https://github.com/gettalong/kramdown/issues/69 */
.table-wrapper {
  overflow-x: auto;
}

td, th {
  padding: 0.1em 0.75em;
}
@media (max-width: 500px) {
  td, th {
    padding-left: 0.375em;
    padding-right: 0.375em;
  }
}
tr:nth-child(even) {
  background: rgba(0, 0, 0, 5%);
}
thead {
  border-bottom: 1px solid grey;
  font-weight: bold;
}

header {
  margin-bottom: 1.5em;
}
header a:not(:hover) {
  text-decoration: none;
}
#blog-title {
  hyphens: none;
  font-variant: small-caps;
  font-size: 1.5em;
  font-weight: normal;
  text-align: center;
  line-height: 1em;
}
#info-list {
  list-style: none;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 0.5em 2em;
}
#info-list li {
  margin: 0;
}

#page-footer {
  border-top: 1px solid lightgrey;
  padding-top: 0.75em;
  color: grey;
  text-align: right;
}

.clear { clear: both; margin: 0; }


main {
    line-height: 1.5em;

    position: relative;
    z-index: 10;
}

a[href] {
    color: inherit;
    text-decoration: underline;
}

/*  The authorship info */
#info-intro {
    font-style: italic;
    text-align: center;
}

/* code */

code, pre {
  font-family: monospace;
  font-variant: none;
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre {
  background: #f0f0f0;
}
code {
    background: #f7f7f7;
    padding: 0 0.1em;
    font-size: 0.9em;
    border-radius: 3px;
    border: 1px solid lightgrey;
}
pre code {
    background: none;
    padding: 0;
    -moz-hyphens: none;
    -webkit-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    border-radius: 0;
    border-width: 0;
}
h1 code, h2 code, h3 code, h4 code {
  background: rgba(255,255,255,0.1);
}

.break-all {
  word-break: break-all;
}

/* quotes and similar */

blockquote {
    border: solid #eee;
    border-width: 0 1px;
    padding: 0 1.2em;
    color: #444;
    position: relative;
    margin-left: 0;
    margin-right: 0;
}

aside {
  padding: 0 1.2em;
  color: #444;
  position: relative;
}
aside[data-icon] {
  padding-left: 2.4em;
}
aside[data-icon]:before {
  content: attr(data-icon);
  position: absolute;
  left: 0;
  text-align: center;
  width: 2.4em;
}

/* images/figures */
img, figure svg {
  max-width: 100%;
  height: auto;
}
figure svg {
  width: 100%;
}
img:not(.inline-image), figure svg {
    display: block;
    margin: 0 auto;
    clear: both;
}

.image-positioner {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

img[data-caption]:before {
    content: attr(data-caption);
}
figure {
  clear: both;
}
figure.image {
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;

  min-width: 100%;
}
figcaption {
  margin: 0 auto;
  max-width: 570px;
  padding: 0 10px;
  text-align: center;
  font-style: italic;
  font-size: 0.9em;
}
figcaption p {
  display: inline;
}
figcaption::before {
  counter-increment: figure;
  content: "Figure " counter(figure) ". ";
}

.highlight table {
  font-size: 0.9em;
  padding: 0em;
  width: 100%;
  table-layout: fixed;
  overflow-y: hidden;
  display: block;
  position: relative;
  z-index: 1;
}
[data-lang] {
  position: relative;
  display: block;
}
[data-lang]::before {
  content: attr(data-lang);
  text-transform: capitalize;
  top: 0;
  right: 0;
  position: absolute;
  font-size: 1.5em;
  color: #f3f3f3;
  z-index: 1;
}

.highlight pre {
  background: transparent;
}
.gutter {
  padding: 0;
  border: solid #ccc;
  border-width: 0 1px 0 0;
  color: #ccc;
}
.lineno {
  width: 25px;
  padding-right: 5px;
}
/* highlight/endhighlight code blocks */
figure.highlight td.code {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}
/* no-highlight/endhighlight code blocks (e.g. in footnotes) */
div.highlight {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}


/* HEADINGS */

h1, h2 {
    font-variant: small-caps;
}

h1, h2, h3, h4 {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
  text-align: left;
}

h1 {
  font-size: 2.2em;
  text-align: center;
  line-height: 1em;
}
h2 {
  font-size: 1.7em;
}
h3 {
  font-size: 1.4em;
}
h4 {
  font-size: 1.2em;
}

/* crates.io badges */

.lib-info {
  float: right;
  width: 150px;
  text-align: center;
  margin: 0 1em;
}
.lib-badge {
  vertical-align: middle;
}
.centered-libs {
  text-align: center;
}
.centered-libs .lib-info {
  float: none;
}

/* external links */

#external-links {
  margin-top: 2.25em;
  text-align: center;
}
.external-label {
  font-weight: bold;
}
#external-links ul {
  list-style: none;
  display: inline-block;
  padding: 0;
  margin: 0;
}
#external-links li {
  list-style: none;
  display: inline;
}

/* "Footnotes" */

/* the div that holds them */
.footnotes {
    margin-top: 2.25em;
    padding-top: 1.5em;
    border-top: 1px solid rgb(240,240,240);
    font-size: 0.9em;
}
.footnotes ol {
  padding: 0;
}
.footnotes li {
    list-style-position: outside;
    margin-left: 30px;
    margin-right: 10px;
    color: #333;
}

.footnotes li:target, .footnotes li:hover {
    color: black;
    background-color: lightyellow;
}

.footnotes .reversefootnote {
    text-decoration: none;
}

/* extra info after a post */
#more {
  margin-top: 3em;
  padding-top: 1.5em;
  border-top: 1px solid lightgray;
}
#me-icon {
  max-width: 150px;
  height: 150px;
  background: url("/img/me.jpg");
  background-size: cover;
  margin-left: auto;
  margin-right: auto;
  border-radius: 30px;
}
#by-line {
  font-size: 0.8em;
}
#latest-list {
  padding: 0;
  list-style: none;
}
#latest-heading {
  text-align: center;
}
#latest-heading a:not(:hover) {
  text-decoration: none;
}
#latest-list a:hover h3 {
  text-decoration: underline;
}
#latest-list a {
  text-decoration: none;
}
.latest-post {
  padding: 0;
  font-size: 0.8em;
}
.latest-post > h3 {
  font-weight: bold;
}
.latest-post * {
  margin: 0;
}

/* post series */

.post-series {
  font-size: 0.8em;
  border: 1px solid lightgray;
  padding: 0.2em;
  cursor: pointer;
}

.post-series-title {
  font-weight: bold;
  font-size: 1.1em;
}
.post-series-list {
  padding-left: 1.5em;
  margin: 0;
}
.post-series .current {
  font-style: italic;
}

/* archive pages */
ul.post-list {
  list-style: none;
  padding: 0;
}

.post-post + .post-post {
  margin-top: 2em;
}

.post-title {
  font-size: 1.2em;
}

.post-excerpt p {
  display: inline;
}

.post-date {
  font-style: italic;
  white-space: nowrap;
  float: right;
  margin: 0;
  margin-left: 3em;
  font-size: smaller;
}

.post-list .footnote, .post-list .footnotes, .post-list p:empty {
  display: none
}

.post-list-empty {
    text-align: center;
}

/* media queries */


@media only print {
    a {
      text-decoration: none !important;
    }
    header {
        display:none !important;
    }

    h1, h2, h3, h4 {
        padding-left: 0 !important;
    }

    #wrapper {
       max-width: none !important;
    }

    .no-print {
        display: none !important;
    }

    .footnotes .reversefootnote {
         display: none !important;
    }
    [data-lang]::before {
      content: "";
    }
}

    

    
  </style>
  
</head>

<body>
<div id="wrapper">
  <header>
    <h1 id="blog-title"><a href="/">Huon on the internet</a></h1>
    <nav>
      <ul id="info-list" class="no-print">
        <li><a href="/about">About</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="https://github.com/huonw">GitHub</a></li>
        <li><a href="https://bsky.app/profile/huonw.bsky.social">Bluesky</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
      
        <h1 id="title"> What does Rust's “unsafe” mean?</h1>
        
      
      
         <div id="info-intro">
           By <a href="/about">Huon Wilson</a>
           
             &mdash; <span class="date pub-date">24 Jul 2014</span>
           
           
         </div>
      
      <p><a href="http://rust-lang.org/">Rust</a> is an in-development<sup id="fnref:version"><a href="#fn:version" class="footnote" rel="footnote" role="doc-noteref">0</a></sup> systems
programming language with a strong focus on no-overhead memory
safety. This is achieved through a powerful type system (with
similarities to Haskell), and careful tracking of ownership and
pointers, guaranteeing safety. However, this is too restrictive for a
low-level systems language, an escape hatch is occasionally
required. Enter the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword.</p>

<h2 id="poking-holes-in-memory-safety">Poking holes in memory safety</h2>

<p>Rust aims to be memory safe, so that, by default, code cannot crash
(or be exploited) due to dangling pointers or iterator
invalidation. However, there are things that cannot fit into the type
system, for example, it is not possible to get the raw interactions
with the operating system and system libraries (like memory allocators
and thread spawning) to be truly safe. Detailed human knowledge about
how to use them safely is required to be encoded at some point, and
this is not easily checkable by a compiler: mistakes can be made.</p>

<p>Other memory safe languages (e.g. managed ones like Python or Haskell)
have all this knowledge encoded in the implementations of their
underlying virtual machines/runtime systems, usually written in
C. Rust doesn’t have a heavy-weight VM or runtime, but still needs to
provide (preferably safe) interfaces in some manner.</p>

<p>Rust fills these holes with the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword, which opts in to
possibly dangerous behaviour; like calling into the operating system
and external libraries via
<a href="http://doc.rust-lang.org/master/guide-ffi.html">the foreign function interface (FFI)</a>,
or handling possibly-invalid machine pointers directly.</p>

<p>Rust uses <code class="language-plaintext highlighter-rouge">unsafe</code> to build all the abstractions seen in the standard
library: the vast majority of it is written in Rust, including
fundamental types like
<a href="http://doc.rust-lang.org/master/std/rc/struct.Rc.html">the reference counted <code class="language-plaintext highlighter-rouge">Rc</code></a>,
<a href="http://doc.rust-lang.org/master/std/vec/struct.Vec.html">the dynamic vector <code class="language-plaintext highlighter-rouge">Vec</code></a>,
and
<a href="http://doc.rust-lang.org/master/std/collections/hashmap/struct.HashMap.html"><code class="language-plaintext highlighter-rouge">HashMap</code></a>,
with only
<a href="https://github.com/rust-lang/rust/tree/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/rt">a few small C shims</a>
and some external non-Rust libraries like jemalloc and libuv.</p>

<h2 id="unsafe"><code class="language-plaintext highlighter-rouge">unsafe</code></h2>

<p>There are two ways in which one can opt-in to these possibly dangerous
behaviours: with an <code class="language-plaintext highlighter-rouge">unsafe</code> block, or with an <code class="language-plaintext highlighter-rouge">unsafe</code> function.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">// calling some C functions imported via FFI:</span>

<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">some_c_function</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">another_c_function</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// illegal, not inside an `unsafe` context</span>
    <span class="c1">// yet_another_c_function();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Being inside an <code class="language-plaintext highlighter-rouge">unsafe</code> context allows one to (not necessarily
complete):</p>

<ol>
  <li>call functions marked <code class="language-plaintext highlighter-rouge">unsafe</code> (this includes FFI functions)</li>
  <li>dereference raw pointers (the <code class="language-plaintext highlighter-rouge">*const</code> and <code class="language-plaintext highlighter-rouge">*mut</code> types), which can
  possibly be <code class="language-plaintext highlighter-rouge">NULL</code>, or otherwise invalid</li>
  <li>access a mutable global variable</li>
  <li>use inline assembly</li>
</ol>

<p>All of these can easily cause large problems. For example, a shared
reference <code class="language-plaintext highlighter-rouge">&amp;T</code> is a machine pointer, but it <em>must</em> always point to a
valid value of type <code class="language-plaintext highlighter-rouge">T</code>; all four of the above can cause this to be
violated:</p>

<ol>
  <li>
    <p>There is an <code class="language-plaintext highlighter-rouge">unsafe</code> function
  <a href="http://doc.rust-lang.org/master/std/mem/fn.transmute.html"><code class="language-plaintext highlighter-rouge">std::mem::transmute</code></a>
  which takes the bytes of its argument and pretends they are of any
  type one wants, thus, one can create an invalid <code class="language-plaintext highlighter-rouge">&amp;</code> pointer by
  reinterpreting an integer: <code class="language-plaintext highlighter-rouge">transmute::&lt;uint, &amp;Vec&lt;int&gt;&gt;(0)</code>.</p>
  </li>
  <li>
    <p>A raw pointer <code class="language-plaintext highlighter-rouge">p: *const T</code> can legally be <code class="language-plaintext highlighter-rouge">NULL</code>. The
  “rereferencing” operation <code class="language-plaintext highlighter-rouge">&amp;*p</code> creates a reference <code class="language-plaintext highlighter-rouge">&amp;T</code> pointing to
  <code class="language-plaintext highlighter-rouge">p</code>s data, a no-op at runtime, since <code class="language-plaintext highlighter-rouge">*const T</code> and <code class="language-plaintext highlighter-rouge">&amp;T</code> are both
  just a single pointer under the hood. If <code class="language-plaintext highlighter-rouge">p</code> is <code class="language-plaintext highlighter-rouge">NULL</code> this allows
  one to create a <code class="language-plaintext highlighter-rouge">NULL</code> <code class="language-plaintext highlighter-rouge">&amp;T</code>: invalid!</p>
  </li>
  <li>
    <p>If one has <code class="language-plaintext highlighter-rouge">static mut X: Option&lt;i64&gt; = Some(1234);</code>, one can use
  pattern matching to get a reference <code class="language-plaintext highlighter-rouge">r: &amp;i64</code> pointing to the <code class="language-plaintext highlighter-rouge">1234</code>
  integer, but another thread can overwrite <code class="language-plaintext highlighter-rouge">X</code> with <code class="language-plaintext highlighter-rouge">None</code>, leaving
  <code class="language-plaintext highlighter-rouge">r</code> dangling.</p>
  </li>
  <li>
    <p>Inline assembly can set arbitrary registers to arbitrary values,
including setting a register meant to be holding a <code class="language-plaintext highlighter-rouge">&amp;T</code> to zero.</p>
  </li>
</ol>

<h2 id="what-does-unsafe-really-mean">What does <code class="language-plaintext highlighter-rouge">unsafe</code> really mean?</h2>

<p>An <code class="language-plaintext highlighter-rouge">unsafe</code> context is the programmer telling the compiler that the
code is guaranteed to be safe due to invariants impossible to express
in the type system, and that it satisfies
<a href="http://doc.rust-lang.org/nightly/reference.html#behavior-considered-undefined">the invariants that Rust itself imposes</a>.</p>

<p>These invariants are assumed to never be broken, even inside <code class="language-plaintext highlighter-rouge">unsafe</code>
code blocks, and the compiler compiles and optimises with this
assumption. Thus, breaking any of those invariants is
<a href="https://en.wikipedia.org/wiki/Undefined_behaviour">undefined behaviour</a><sup id="fnref:ub-llvm"><a href="#fn:ub-llvm" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>
and can leave a program doing “anything”, even making
<a href="http://www.catb.org/jargon/html/N/nasal-demons.html">demons fly out your nose</a>.</p>

<p>That is, an <code class="language-plaintext highlighter-rouge">unsafe</code> context is not a free pass to mutate anything and
everything, nor is it a free pass to mangle pointers and alias
references: all the normal rules of Rust still apply, the compiler is
just giving the programmer more power, at the expense of leaving it up
to the programmer to ensure everything is safe.</p>

<p>A non-<code class="language-plaintext highlighter-rouge">unsafe</code> function using <code class="language-plaintext highlighter-rouge">unsafe</code> internally <em>should</em> be
implemented to be safe to call; that is, there is no circumstance or
set of arguments that can make the function violate
<a href="http://doc.rust-lang.org/nightly/reference.html#behavior-considered-undefined">any invariants</a>. If
there are such circumstances, it should be marked <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<p>This rule is most important for public, exported functions; private
functions are guaranteed to only be called in a limited set of
configurations (since all calls are in the crate/module in which it is
defined), so the author has more flexibility about what sort of safety
guarantees they give. However, marking possibly-dangerous things
<code class="language-plaintext highlighter-rouge">unsafe</code> helps the compiler help the programmer do the right thing, so
is encouraged even for private items.</p>

<h3 id="case-study-vec">Case study: <code class="language-plaintext highlighter-rouge">Vec</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> type is
<a href="https://github.com/rust-lang/rust/blob/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/libcollections/vec.rs#L55-L59">defined</a>
as:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">uint</span><span class="p">,</span>
    <span class="n">cap</span><span class="p">:</span> <span class="nb">uint</span><span class="p">,</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are (at least) two invariants here:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ptr</code> holds an allocation with enough space for <code class="language-plaintext highlighter-rouge">cap</code> values of type <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>That allocation holds <code class="language-plaintext highlighter-rouge">len</code> valid values of type <code class="language-plaintext highlighter-rouge">T</code> (i.e. the
first <code class="language-plaintext highlighter-rouge">len</code> out of <code class="language-plaintext highlighter-rouge">cap</code> of the <code class="language-plaintext highlighter-rouge">T</code>s are valid, implying <code class="language-plaintext highlighter-rouge">len &lt;=
cap</code>)</li>
</ol>

<p>It’s not feasible to express these in Rust’s type system, so they are
guaranteed by a careful implementation. The implementation is then
forced to use <code class="language-plaintext highlighter-rouge">unsafe</code> to assuage the compiler’s doubts about certain
operations. The compiler does not and cannot understand the invariants
stated above, and so cannot be sure that
<a href="https://github.com/rust-lang/rust/blob/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/libcollections/vec.rs#L1430">creating a slice view into the vector</a>
is safe. It is implemented like so:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">as_slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">mem</span><span class="p">::</span><span class="nf">transmute</span><span class="p">(</span><span class="n">Slice</span> <span class="p">{</span> <span class="n">data</span><span class="p">:</span> <span class="k">self</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="n">len</span><span class="p">:</span> <span class="k">self</span><span class="py">.len</span> <span class="p">})</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And you can see that it could easily be unsafe e.g. if one
accidentally wrote <code class="language-plaintext highlighter-rouge">self.cap</code> instead of <code class="language-plaintext highlighter-rouge">self.len</code>, the resulting
slice would be too long and the last elements of it would be
uninitialised data. The compiler can’t verify that this is correct,
and so assumes the worst, disallowing it without the explicit opt-in.</p>

<p>Another thing to note is these <code class="language-plaintext highlighter-rouge">Vec</code> invariants are required to always
hold or else <code class="language-plaintext highlighter-rouge">Vec</code> will be allowing incorrect behaviour to happen via
the safe methods it exposes (e.g. if someone could increase <code class="language-plaintext highlighter-rouge">len</code>
without initialising the elements appropriately, the <code class="language-plaintext highlighter-rouge">as_slice</code> method
above would be broken).</p>

<p>Unfortunately, it’s not possible to get the Rust compiler to directly
enforce them, so the <code class="language-plaintext highlighter-rouge">Vec</code> API has to be careful to guarantee that
they can’t be violated; part of this is keeping the fields private, so
they cannot be directly changed, another part is being careful to mark
the <code class="language-plaintext highlighter-rouge">unsafe</code> parts of the API as <code class="language-plaintext highlighter-rouge">unsafe</code>, e.g.
<a href="http://doc.rust-lang.org/master/collections/vec/struct.Vec.html#method.set_len">the <code class="language-plaintext highlighter-rouge">set_len</code> method</a>
can directly change the <code class="language-plaintext highlighter-rouge">len</code> field.</p>

<h3 id="case-study-malloc">Case study: <code class="language-plaintext highlighter-rouge">malloc</code></h3>

<p>The C function <code class="language-plaintext highlighter-rouge">malloc</code> is described by my man page as the following:</p>

<blockquote>
  <p>The <code class="language-plaintext highlighter-rouge">malloc()</code> function allocates size bytes and returns a pointer to the
allocated memory.  The memory is not initialized.  If size is  0,  then
<code class="language-plaintext highlighter-rouge">malloc()</code>  returns either <code class="language-plaintext highlighter-rouge">NULL</code>, or a unique pointer value that can later
be successfully passed to <code class="language-plaintext highlighter-rouge">free()</code>.</p>

  <p>The <code class="language-plaintext highlighter-rouge">malloc()</code> and <code class="language-plaintext highlighter-rouge">calloc()</code> functions return a pointer to  the  allocated
memory,  which  is  suitably  aligned for any built-in type.  On error,
these functions return <code class="language-plaintext highlighter-rouge">NULL</code>.  […].</p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">libc</code> crate predefines most of the common symbols from the <code class="language-plaintext highlighter-rouge">libc</code>
on various platforms, including <code class="language-plaintext highlighter-rouge">libc::malloc</code>. Let’s write a safe
program that creates memory for, stores and prints an 8-byte <code class="language-plaintext highlighter-rouge">i64</code>
integer, carefully justifying why we know more than the compiler, and
thus why each <code class="language-plaintext highlighter-rouge">unsafe</code> is safe (in a perfect world all <code class="language-plaintext highlighter-rouge">unsafe</code> blocks
would be justified/proved correct).</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="k">extern</span> <span class="k">crate</span> <span class="n">libc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pointer</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i64</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
        <span class="c1">// rustc doesn't know what `malloc` does, and so doesn't know</span>
        <span class="c1">// that calling it with argument 8 is always safe; but we do,</span>
        <span class="c1">// so we override the compiler's concern with</span>
        <span class="c1">// `unsafe`. (`malloc` returns a `*mut libc::c_void` so we</span>
        <span class="c1">// need to cast it to the type we want.)</span>
        <span class="nn">libc</span><span class="p">::</span><span class="nf">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i64</span>
    <span class="p">};</span>

    <span class="c1">// we know that the only failure condition is the pointer being</span>
    <span class="c1">// NULL, in any other circumstance the pointer points to a valid</span>
    <span class="c1">// memory allocation of at least 8 bytes.</span>
    <span class="k">if</span> <span class="n">pointer</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"could not allocate"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// here, the only thing missing is initialisation, the memory</span>
        <span class="c1">// is valid but uninitialised, so lets fix that. Since it is</span>
        <span class="c1">// not initialised, we have to be careful to avoid running</span>
        <span class="c1">// destructors on the old memory; via `std::ptr::write`.</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// allocation is valid, and the memory is uninitialised,</span>
            <span class="c1">// so this is safe and correct.</span>
            <span class="nn">ptr</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="mi">1234i64</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// now `pointer` is looking at initialised, valid memory, so</span>
        <span class="c1">// it is valid to read from it, and to obtain a reference to</span>
        <span class="c1">// it.</span>
        <span class="k">let</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i64</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="n">pointer</span> <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"The data is {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
        <span class="c1">// prints: The data is 1234</span>
    <span class="p">}</span>

    <span class="c1">// (leaking memory is not `unsafe`.)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>(Keen eyes will note that <code class="language-plaintext highlighter-rouge">i64</code> doesn’t have a destructor and so the
<a href="http://doc.rust-lang.org/master/std/ptr/fn.write.html"><code class="language-plaintext highlighter-rouge">ptr::write</code></a>
call isn’t strictly required, but it’s good practice.)</p>

<h2 id="faq-why-isnt-unsafe-viral">FAQ: Why isn’t <code class="language-plaintext highlighter-rouge">unsafe</code> viral?</h2>

<p>One <em>might</em> expect a function containing an <code class="language-plaintext highlighter-rouge">unsafe</code> block to be
<code class="language-plaintext highlighter-rouge">unsafe</code> to call, that is, <code class="language-plaintext highlighter-rouge">unsafe</code>ty infects everything it touches,
similar to how Haskell forces one to mark all impure calculations with
the <code class="language-plaintext highlighter-rouge">IO</code> type.</p>

<p>However, this is not the case, <code class="language-plaintext highlighter-rouge">unsafe</code> is just an implementation
detail; if a safe function uses <code class="language-plaintext highlighter-rouge">unsafe</code> internally, it just means the
author has been forced to step around the type system, but still
exposes a safe interface.</p>

<p>More pragmatically, if <code class="language-plaintext highlighter-rouge">unsafe</code> were viral, every Rust program ever
would be entirely <code class="language-plaintext highlighter-rouge">unsafe</code>, since the whole standard library is
written in Rust, built on top of <code class="language-plaintext highlighter-rouge">unsafe</code> internals.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The <code class="language-plaintext highlighter-rouge">unsafe</code> marker is a way to step around Rust’s type system; by
telling <code class="language-plaintext highlighter-rouge">rustc</code> that there are external conditions/invariants that
guarantee correctness: the compiler steps back and locally leaves the
programmer to verify that
<a href="http://doc.rust-lang.org/reference.html#behavior-considered-undefined">various properties</a>
hold. This allows Rust to write very low-level code like C, but still
be memory safe by default, by forcing programmers to opt-in to the
risky behaviour.</p>

<p>The
<a href="http://doc.rust-lang.org/master/guide-unsafe.html">“Writing Safe Unsafe and Low-Level Code”</a>
provides guidance and tips about using <code class="language-plaintext highlighter-rouge">unsafe</code> correctly.</p>

<section id="external-links" class="no-print">
  
  <div id="comments">
    <span class="external-label">Comments:</span>
    <ul class="external-list">
      

      
<li class="external-link"><a href="http://www.reddit.com/r/rust/comments/2bhwgc/what_does_rusts_unsafe_mean/">/r/rust</a></li>


      
<li class="external-link"><a href="http://www.reddit.com/r/programming/comments/2bhwhl/what_does_rusts_unsafe_mean/">/r/programming</a></li>


      

      

      
    </ul>
  </div>
  
  <div id="external-page">
    <span class="external-label">Share this on</span>
    <ul class="external-list">
      <li class="external-link"><a href="https://bsky.app/intent/compose?text=What%20does%20Rust's%20%E2%80%9Cunsafe%E2%80%9D%20mean?%20by%20@huonw.bsky.social%20https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/" target="_blank" rel="nofollow noopener" title="Share on Bluesky">Bluesky</a></li>
      <li class="external-link"><a href="https://twitter.com/intent/tweet?text=What%20does%20Rust's%20%E2%80%9Cunsafe%E2%80%9D%20mean?%20%23rustlang&amp;url=https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/&amp;via=huon_w" target="_blank" rel="nofollow noopener" title="Share on Twitter">Twitter</a></li>
      <li class="external-link"><a href="https://facebook.com/sharer.php?u=https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/" rel="nofollow noopener" target="_blank" title="Share on Facebook">Facebook</a></li>
      <li class="external-link"><a href="https://www.reddit.com/submit?url=https://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/&amp;title=What%20does%20Rust's%20%E2%80%9Cunsafe%E2%80%9D%20mean?" rel="nofollow noopener" target="_blank" title="Share on Reddit">Reddit</a></li>
    </ul>
  </div>
</section>

<div class="footnotes" role="doc-endnotes">
  <ol start="0">
    <li id="fn:version">
      <p>The code in this post compiles with <code class="language-plaintext highlighter-rouge">rustc 0.12.0-pre-nightly (aa0e35bc6 2014-07-22 00:26:21 +0000)</code>. <a href="#fnref:version" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ub-llvm">
      <p><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">“What Every C Programmer Should Know About Undefined Behaviour”</a>
        is a series of articles highlighting how insidious undefined behaviour
        can be, leading to subtly (or not so subtly) broken programs. <a href="#fnref:ub-llvm" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>

    
    <div id="no-ai">This article is from a human: I used no AI to write it.</div>
    <footer id="more" class="no-print">
      <div id="by-line">
  <a href="/about"><div class="no-print" id="me-icon"></div></a>

<p>I'm <a href="https://bsky.app/profile/huonw.bsky.social"><strong>Huon Wilson</strong></a>, a
 mathematically and statistically inclined software engineer.
 I have been a long-term volunteer
 on <a href="http://rust-lang.org">Rust</a>'s core team, a
 compiler engineer on the <a href="https://swift.org/">Swift</a> team
 at Apple, and a senior software engineer at CSIRO's Data61, working on the <a href="https://github.com/stellargraph/stellargraph">StellarGraph
 graph machine learning library</a>.
</p>
</div>
      <h2 id="latest-heading"><a href="/blog">Latest posts</a></h2>
      
      <nav>
        <ul id="latest-list"><!--
           
           --><li class="latest-post">
                <a href="/blog/2025/12/magit-insert-worktrees/">
                   <h3>magit-insert-worktrees improves status buffers</h3>
                     <p>When using Emacs’ Magit and Git worktrees, adding the magit-insert-worktrees section inserter gives an nice overview of them in the status buffer.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/12/typescript-monotonic/">
                   <h3>TypeScript strictness is non-monotonic: strict-null-checks and no-implicit-any interact</h3>
                     <p>A curiosity about the interaction between two TypeScript compiler settings, that lead to errors that appear and disappear, as one increases strictness.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/11/piraite/">
                   <h3>Context privateering: debugging custom instructions like a pirate</h3>
                     <p>Adding “always speak like a pirate” to instructions for an AI tool is a helpful generic trick for debugging whether those instructions are being read correctly.
</p>
                   
                 </a>
            </li><!--
          
      --></ul>
      </nav>
    </footer>
    
  </main>

  <footer id="page-footer">
    <span>Huon Wilson &mdash; <span class="date">2026</span></span>
  </footer>
</div>



<!-- Default Statcounter code for huonw.github.io
http://huonw.github.io -->
<script type="text/javascript">
var sc_project=7439209;
var sc_invisible=1;
var sc_security="b96244c7";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="hit counter"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/7439209/0/b96244c7/1/"
alt="hit counter"
referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
<!-- End of Statcounter Code -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62534856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-62534856-1');
</script>



</body> </html>
