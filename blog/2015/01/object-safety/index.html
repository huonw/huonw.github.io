<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>  Object Safety |  Huon on the internet</title>

  <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Atom feed">
  <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RSS feed">
  
  <link rel="canonical" href="https://huonw.github.io/blog/2015/01/object-safety/">

  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  

  
  <meta name="description" content="An overview of so-called &quot;object safety&quot; in Rust, and why it is necessary for trait objects.
" />

  
  <meta name="twitter:card" content="summary" />
  
  <meta name="twitter:site" content="@huon_w" />
  <meta name="twitter:title" content="Object Safety" />
  <meta name="twitter:description" content="An overview of so-called &quot;object safety&quot; in Rust, and why it is necessary for trait objects.
" />
  <meta name="twitter:url" content="https://huonw.github.io/blog/2015/01/object-safety/">

  <!-- facebook -->
  <meta property="og:url" content="https://huonw.github.io/blog/2015/01/object-safety/" />
  <meta property="og:title" content="Object Safety" />
  <meta property="og:description" content="An overview of so-called &quot;object safety&quot; in Rust, and why it is necessary for trait objects.
" />
  
  <meta property="og:type" content="article" />
  
  
  
  <style>
    /*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}html{line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0;font-family:system-ui, -apple-system,'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type='button'],[type='reset'],[type='submit'],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}


    
      /* Borrowed from mojombo: https://github.com/mojombo/mojombo.github.com/blob/master/css/syntax.css */

.lineno { width: 2em; text-align:right; }
.highlight pre {
  white-space: pre;
}
.highlight .c { color: #777; font-style: italic; } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */


html {
    min-height:100%;
}

* {
  margin: 0;
}
* + * {
  margin-top: 0.75em;
}


body {
  padding:0px;
    counter-reset: footnotes;
    counter-reset: figure;
    margin:0px;
    font-size: 18px;
    background: white;
    color: #101010;

    font-variant: common-ligatures;
    -moz-font-feature-settings: "kern" on;
    -webkit-font-feature-settings: "kern" on;
    font-feature-settings: "kern" on;
}

#wrapper {
    margin: 0 auto;
    max-width: 630px;
    padding: 0.75em 15px;
    width: 100%;
    position:relative;
}

.lazily-filled {
  position: relative;
}
.lazily-filled > * {
  z-index: 0;
}
.lazily-filled::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgb(229, 236, 246);
  z-index: 1;
}
.lazily-filled::after {
  position: absolute;
  top: 50%;
  left: 50%;
  content: "";
  display: block;
  width: 128px;
  height: 128px;
  margin-left: -64px;
  margin-top: -64px;
  border-radius: 50%;
  border: 12px solid;
  border-color: white transparent;
  animation: spinner 5s linear;
  /* eventually stop animating when it's hidden */
  animation-iteration-count: 10;
  z-index: 2;
}
.lazily-filled::before, .lazily-filled::after {
  opacity: 0;
  transition: all 0.5s ease;
  pointer-events: none;
}
.lazily-filled:empty::before, .lazily-filled:empty::after {
  opacity: 1;
  animation-iteration-count: infinite;
  visibility: visible;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.plotly-plot * + * {
  margin-top: 0;
}

/* wonky safari */
.plotly text[style*="white-space: pre"] {
  white-space: nowrap !important;
}


/* lists */
li + li {
  margin-top: 0.5em;
}
ul, ol {
  padding-left: 1.5em;
}

table {
  margin-left: auto;
  margin-right: auto;
  border-collapse: collapse;
  text-align: left;
}

td, th {
  padding: 0.1em 0.75em;
}
@media (max-width: 500px) {
  td, th {
    padding-left: 0.375em;
    padding-right: 0.375em;
  }
}
tr:nth-child(even) {
  background: rgba(0, 0, 0, 5%);
}
thead {
  border-bottom: 1px solid grey;
  font-weight: bold;
}

header {
  margin-bottom: 1.5em;
}
header a:not(:hover) {
  text-decoration: none;
}
#blog-title {
  hyphens: none;
  font-variant: small-caps;
  font-size: 1.5em;
  font-weight: normal;
  text-align: center;
  line-height: 1em;
}
#info-list {
  list-style: none;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
}
#info-list li {
  margin: 0 1em;
}

#page-footer {
  border-top: 1px solid lightgrey;
  padding-top: 0.75em;
  color: grey;
  text-align: right;
}

.clear { clear: both; margin: 0; }


main {
    text-align:justify;
    -moz-hyphens: auto;
    -webkit-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
    line-height: 1.5em;

    position: relative;
    z-index: 10;
}

a[href] {
    color: inherit;
    text-decoration: underline;
}

/*  The authorship info */
#info-intro {
    font-style: italic;
    text-align: center;
}

/* code */

code, pre {
  font-family: monospace;
  font-variant: none;
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre {
  background: #f0f0f0;
}
code {
    background: #f7f7f7;
    padding: 0 0.1em;
    font-size: 0.9em;
    border-radius: 3px;
    border: 1px solid lightgrey;
}
pre code {
    background: none;
    padding: 0;
    -moz-hyphens: none;
    -webkit-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    border-radius: 0;
    border-width: 0;
}
h1 code, h2 code, h3 code, h4 code {
  background: rgba(255,255,255,0.1);
}

.break-all {
  word-break: break-all;
}

/* quotes and similar */

blockquote {
    border: solid #eee;
    border-width: 0 1px;
    padding: 0 1.2em;
    color: #444;
    position: relative;
    margin-left: 0;
    margin-right: 0;
}

aside {
  padding: 0 1.2em;
  color: #444;
  position: relative;
}
aside[data-icon] {
  padding-left: 2.4em;
}
aside[data-icon]:before {
  content: attr(data-icon);
  position: absolute;
  left: 0;
  text-align: center;
  width: 2.4em;
}

/* images/figures */
img, figure svg {
  max-width: 100%;
  height: auto;
}
figure svg {
  width: 100%;
}
img:not(.inline-image), figure svg {
    display: block;
    margin: 0 auto;
    clear: both;
}

.image-positioner {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

img[data-caption]:before {
    content: attr(data-caption);
}
figure {
  clear: both;
}
figure.image {
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;

  min-width: 100%;
}
figcaption {
  margin: 0 auto;
  max-width: 570px;
  padding: 0 10px;
  text-align: center;
  font-style: italic;
  font-size: 0.9em;
}
figcaption p {
  display: inline;
}
figcaption::before {
  counter-increment: figure;
  content: "Figure " counter(figure) ". ";
}

.highlight table {
  font-size: 0.9em;
  padding: 0em;
  width: 100%;
  table-layout: fixed;
  overflow-y: hidden;
  display: block;
  position: relative;
  z-index: 1;
}
[data-lang] {
  position: relative;
  display: block;
}
[data-lang]::before {
  content: attr(data-lang);
  text-transform: capitalize;
  top: 0;
  right: 0;
  position: absolute;
  font-size: 1.5em;
  color: #f3f3f3;
  z-index: 1;
}

.highlight pre {
  background: transparent;
}
.gutter {
  padding: 0;
  border: solid #ccc;
  border-width: 0 1px 0 0;
  color: #ccc;
}
.lineno {
  width: 25px;
  padding-right: 5px;
}
.highlight td.code {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}


/* HEADINGS */

h1, h2 {
    font-variant: small-caps;
}

h1, h2, h3, h4 {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
  text-align: left;
}

h1 {
  font-size: 2.2em;
  text-align: center;
  line-height: 1em;
}
h2 {
  font-size: 1.7em;
}
h3 {
  font-size: 1.4em;
}
h4 {
  font-size: 1.2em;
}

/* crates.io badges */

.lib-info {
  float: right;
  width: 150px;
  text-align: center;
  margin: 0 1em;
}
.lib-badge {
  vertical-align: middle;
}
.centered-libs {
  text-align: center;
}
.centered-libs .lib-info {
  float: none;
}

/* external links */

#external-links {
  margin-top: 2.25em;
  text-align: center;
}
.external-label {
  font-weight: bold;
}
#external-links ul {
  list-style: none;
  display: inline-block;
  padding: 0;
  margin: 0;
}
#external-links li {
  list-style: none;
  display: inline;
}

/* "Footnotes" */

/* the div that holds them */
.footnotes {
    margin-top: 2.25em;
    padding-top: 1.5em;
    border-top: 1px solid rgb(240,240,240);
    font-size: 0.9em;
}
.footnotes ol {
  padding: 0;
}
.footnotes li {
    list-style-position: outside;
    margin-left: 30px;
    margin-right: 10px;
    color: #333;
}

.footnotes li:target, .footnotes li:hover {
    color: black;
    background-color: lightyellow;
}

.footnotes .reversefootnote {
    text-decoration: none;
}

/* extra info after a post */
#more {
  margin-top: 3em;
  padding-top: 1.5em;
  border-top: 1px solid lightgray;
}
#me-icon {
  max-width: 150px;
  height: 150px;
  background: url("/img/me.jpg");
  background-size: cover;
  margin-left: auto;
  margin-right: auto;
  border-radius: 30px;
}
#by-line {
  font-size: 0.8em;
}
#latest-list {
  padding: 0;
  list-style: none;
}
#latest-heading {
  text-align: center;
}
#latest-heading a:not(:hover) {
  text-decoration: none;
}
#latest-list a:hover h3 {
  text-decoration: underline;
}
#latest-list a {
  text-decoration: none;
}
.latest-post {
  padding: 0;
  font-size: 0.8em;
}
.latest-post > h3 {
  font-weight: bold;
}
.latest-post * {
  margin: 0;
}

/* post series */

.post-series {
  font-size: 0.8em;
  border: 1px solid lightgray;
  padding: 0.2em;
  cursor: pointer;
}

.post-series-title {
  font-weight: bold;
  font-size: 1.1em;
}
.post-series-list {
  padding-left: 1.5em;
  margin: 0;
}
.post-series .current {
  font-style: italic;
}

/* archive pages */
ul.post-list {
  list-style: none;
  padding: 0;
}

.post-post {
  margin: 0;
}

.post-post + .post-post {
  border-top: 1px dashed  #ddd;
  margin-top: 1em;
  padding-top: 1em;
}

a.post-heading {
  display: flex;
  align-items: baseline;
  text-decoration: none;
  gap: 1em;
}
.post-heading * {
  margin: 0;
}

.post-title {
  font-size: 1.2em;
  flex-grow: 1;
  text-decoration: underline;
}

.post-heading .post-date {
  font-style: italic;
  flex-shrink: 0;
}

.post-excerpt p {
  display: inline;
}

.post-more {
  font-style: italic;
  white-space: nowrap;
  float: right;
  margin: 0;
  font-size: smaller;
}

.post-list .footnote, .post-list .footnotes, .post-list p:empty {
  display: none
}

/* media queries */


@media only print {
    a {
      text-decoration: none !important;
    }
    header {
        display:none !important;
    }

    h1, h2, h3, h4 {
        padding-left: 0 !important;
    }

    #wrapper {
       max-width: none !important;
    }

    .no-print {
        display: none !important;
    }

    .footnotes .reversefootnote {
         display: none !important;
    }
    [data-lang]::before {
      content: "";
    }
}

    

    
  </style>
  
</head>

<body>
<div id="wrapper">
  <header>
    <h1 id="blog-title"><a href="/">Huon on the internet</a></h1>
    <nav>
      <ul id="info-list" class="no-print">
        <li><a href="/about">About</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="https://github.com/huonw">GitHub</a></li>
        <li><a href="https://bsky.app/profile/huonw.bsky.social">Bluesky</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
      
        <h1 id="title"> Object Safety</h1>
        
      
      
         <div id="info-intro">
           By <a href="/about">Huon Wilson</a>
           
             &mdash; <span class="date pub-date">13 Jan 2015</span>
           
           
         </div>
      
      <p>A trait object in <a href="http://rust-lang.org">Rust</a><sup id="fnref:version" role="doc-noteref"><a href="#fn:version" class="footnote" rel="footnote">0</a></sup> can only be
constructed out of traits that satisfy certain restrictions, which are
collectively called “object safety”. This object safety can appear to
be a needless restriction at first, I’ll try to give a deeper
understanding into why it exists and related compiler behaviour.</p>

<p>This is the second (and a half) in a short series of articles on trait
objects. The first
one—<a href="/blog/2015/01/peeking-inside-trait-objects/">Peeking inside Trait Objects</a>—set the scene by
looking into the low-level implementation details of trait objects,
and the
first-and-a-half-th—<a href="/blog/2015/01/the-sized-trait/">an interlude about <code class="language-plaintext highlighter-rouge">Sized</code></a>—looked
at the special <code class="language-plaintext highlighter-rouge">Sized</code> trait. I strongly recommended at least glancing
over it to be familiar with trait objects, vtables and <code class="language-plaintext highlighter-rouge">Sized</code>,
since this post builds on those concepts.</p>

<details class="post-series">
  <summary class="post-series-title">Other posts in this series on trait objects</summary>
  <ol class="post-series-list">
    <li class=""><a href="/blog/2015/01/peeking-inside-trait-objects/">Peeking inside Trait Objects</a></li>
    <li class=""><a href="/blog/2015/01/the-sized-trait/">The Sized Trait</a></li>
    <li class="current"><a href="/blog/2015/01/object-safety/">Object Safety</a></li>
    <li class=""><a href="/blog/2015/05/where-self-meets-sized-revisiting-object-safety/">Where Self Meets Sized: Revisting Object Safety</a></li>
  </ol>
</details>

<h2 id="motivation">Motivation</h2>

<p>The notion of object safety was introduced in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>, with
the motivation that one should be able to use the dynamic trait object
types <code class="language-plaintext highlighter-rouge">Foo</code> (as a type) in more places where a “static” <code class="language-plaintext highlighter-rouge">Foo</code> (as a
trait) generic is expected. In a sense, it is bringing the two uses of
traits—static dispatch and dynamic dispatch—closer together,
reducing special handling in the language.</p>

<p>The high-level behaviour/restriction imposed by that RFC is: a trait
object—<code class="language-plaintext highlighter-rouge">&amp;Foo</code>, <code class="language-plaintext highlighter-rouge">&amp;mut Foo</code>, etc.—can only be made out of a trait
<code class="language-plaintext highlighter-rouge">Foo</code> if <code class="language-plaintext highlighter-rouge">Foo</code> is object safe. This section will focus on borrowed <code class="language-plaintext highlighter-rouge">&amp;</code>
trait objects, but what is said applies to any.</p>

<p>Let’s look at an example of the things object safety enables: if we
have a trait <code class="language-plaintext highlighter-rouge">Foo</code> and a function like</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">func</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Foo</span> <span class="o">+</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It would be nice to be able to call it like <code class="language-plaintext highlighter-rouge">func(object)</code> where
<code class="language-plaintext highlighter-rouge">object: &amp;Foo</code>; that is, take <code class="language-plaintext highlighter-rouge">T</code> to be the dynamically sized type
<code class="language-plaintext highlighter-rouge">Foo</code>. As you might guess from the context, it is not possible to
do this without some notion of object safety: the arbitrary piece of
code <code class="language-plaintext highlighter-rouge">...</code> can do bad (uncontrolled) things.</p>

<p>Take it on faith (for a few paragraphs) that calling a generic method
is one example of something that can’t be done on a trait object. So,
let’s define a trait and a function like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Bad</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">generic_method</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">func</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Bad</span> <span class="o">+</span> <span class="o">?</span><span class="n">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="nf">.generic_method</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span> <span class="c">// A = &amp;str</span>
    <span class="n">x</span><span class="nf">.generic_method</span><span class="p">(</span><span class="mi">1_u8</span><span class="p">);</span> <span class="c">// A = u8</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The function <code class="language-plaintext highlighter-rouge">func</code> <em>can’t</em> be called like <code class="language-plaintext highlighter-rouge">foo(obj)</code> where <code class="language-plaintext highlighter-rouge">obj</code> is a
trait object <code class="language-plaintext highlighter-rouge">&amp;Bad</code> because the generic method calls are
illegal. There’s a possible approaches here, like</p>

<ol>
  <li>have signatures like <code class="language-plaintext highlighter-rouge">&lt;T: Foo + ?Sized&gt;(x: &amp;T)</code> not work with <code class="language-plaintext highlighter-rouge">T =
  Foo</code> by default, for any trait <code class="language-plaintext highlighter-rouge">Foo</code>,</li>
  <li>check the body of the function to see if it is legal to have <code class="language-plaintext highlighter-rouge">T =
Bad</code> when we ask for that, or</li>
  <li>ensure that we can never pass a <code class="language-plaintext highlighter-rouge">&amp;Bad</code> into <code class="language-plaintext highlighter-rouge">func</code>.</li>
</ol>

<p>Approach 1 is what existed before object safety, and is what object
safety was designed to solve. Approach 2 violates Rust’s goal of
needing to know only the signatures of any function/method called to
type-check a program. That is, if one satisfies the signature one can
call it, unlike C++, there’s no need to type-check internal code of
each the actual instantiation of a generic because the signatures
guarantee that the internals will be legal.</p>

<p>Approach 3 is the one that Rust takes via object safety, by ensuring
that it is impossible to ever encounter a scenario in which a function
with signature <code class="language-plaintext highlighter-rouge">fn func&lt;T: Foo + ?Sized&gt;(x: &amp;T)</code> that does bad things,
could have <code class="language-plaintext highlighter-rouge">T == Foo</code>. That is, make it so that the only way that a
<code class="language-plaintext highlighter-rouge">&amp;Foo</code> can be created is if there’s no way that <code class="language-plaintext highlighter-rouge">func</code> can misbehave.</p>

<p>Object safety and those sort of function signatures apply particularly
to UFCS (uniform function call syntax), which allows one to call
methods as normal, generic function scoped under the type/trait in
which they are defined, for example, the UFCS function
<code class="language-plaintext highlighter-rouge">Bad::generic_method</code> from the trait above effectively has signature:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nn">Bad</span><span class="p">::</span><span class="n">generic_method</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">:</span> <span class="n">Bad</span> <span class="o">+</span> <span class="o">?</span><span class="n">Sized</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">fn method(&amp;self)</code> comes from a trait <code class="language-plaintext highlighter-rouge">Foo</code>, <code class="language-plaintext highlighter-rouge">x.method()</code> can
always be rewritten to <code class="language-plaintext highlighter-rouge">Foo::method(x)</code> (modulo auto-deref and
auto-ref, which possibly add an <code class="language-plaintext highlighter-rouge">&amp;</code> and/or some number of <code class="language-plaintext highlighter-rouge">*</code>s),
however, without object safety, it may not be possible to write
<code class="language-plaintext highlighter-rouge">trait_object.method()</code> as <code class="language-plaintext highlighter-rouge">Foo::method(trait_object)</code>. Object safety
guarantees this transformation is always valid—making UFCS and
method calls essentially equivalent—by outlawing creating a trait
object in situations where it would be invalid.</p>

<h2 id="how-it-works">How it works</h2>

<p>After <a href="https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md">RFC 546</a> and <a href="https://github.com/rust-lang/rust/pull/20341">PR 20341</a>, making trait objects
automatically work with those sort of generic functions is achieved by
effectively having the compiler implicitly create an implementation of
<code class="language-plaintext highlighter-rouge">Foo</code> (as a trait) for <code class="language-plaintext highlighter-rouge">Foo</code> (as a type). Each method of the trait is
implemented to call into the corresponding method in the vtable. In
the explicit notation of <a href="/blog/2015/01/peeking-inside-trait-objects/">my previous post</a>, the
situation might look something like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// autogenerated impl</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Foo</span><span class="o">+</span><span class="nv">'a</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// `self` is an `&amp;Foo` trait object.</span>

        <span class="c">// load the right function pointer and call it with the opaque data pointer</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.vtable.method1</span><span class="p">)(</span><span class="k">self</span><span class="py">.data</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c">// `self` is an `&amp;mut Foo` trait object</span>

        <span class="c">// as above, passing along the other arguments</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.vtable.method2</span><span class="p">)(</span><span class="k">self</span><span class="py">.data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To be clear: the <code class="language-plaintext highlighter-rouge">.vtable</code> and <code class="language-plaintext highlighter-rouge">.data</code> notation doesn’t work directly
on trait objects, so that code has no hope of compiling, I am just
being explicit about actual behaviour.</p>

<h2 id="object-safety">Object safety</h2>

<p>The rules for object safety were set-out in that initial
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>, with two missed cases identified and resolved in
<a href="https://github.com/rust-lang/rfcs/issues/428">RFC 428</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md">RFC 546</a>. At the time of writing, the
possible ways to be object-unsafe are described
<a href="https://github.com/rust-lang/rust/blob/2127e0d56d85ff48aafce90ab762650e46370b63/src/librustc/middle/traits/object_safety.rs#L30-L52">by two enums</a>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">enum</span> <span class="n">ObjectSafetyViolation</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">/// Self : Sized declared on the trait</span>
    <span class="n">SizedSelf</span><span class="p">,</span>

    <span class="c">/// Method has someting illegal</span>
    <span class="nf">Method</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">ty</span><span class="p">::</span><span class="n">Method</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">MethodViolationCode</span><span class="p">),</span>
<span class="p">}</span>

<span class="c">/// Reasons a method might not be object-safe.</span>
<span class="nd">#[derive(Copy,Clone,Show)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MethodViolationCode</span> <span class="p">{</span>
    <span class="c">/// e.g., `fn(self)`</span>
    <span class="n">ByValueSelf</span><span class="p">,</span>

    <span class="c">/// e.g., `fn foo()`</span>
    <span class="n">StaticMethod</span><span class="p">,</span>

    <span class="c">/// e.g., `fn foo(&amp;self, x: Self)` or `fn foo(&amp;self) -&gt; Self`</span>
    <span class="n">ReferencesSelf</span><span class="p">,</span>

    <span class="c">/// e.g., `fn foo&lt;A&gt;()`</span>
    <span class="n">Generic</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let’s go through each case.</p>

<p><em>Update 2015-05-06</em>: <a href="https://github.com/rust-lang/rfcs/pull/817">RFC 817</a> added more precise control
  over object safety via <code class="language-plaintext highlighter-rouge">where</code> clauses, see
  <a href="/blog/2015/05/where-self-meets-sized-revisiting-object-safety/"><em>Where Self Meets Sized: Revisiting Object Safety</em></a>.</p>

<h3 id="sized-self">Sized <code class="language-plaintext highlighter-rouge">Self</code></h3>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span><span class="p">:</span> <span class="n">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The trait <code class="language-plaintext highlighter-rouge">Foo</code> inherits from <code class="language-plaintext highlighter-rouge">Sized</code>, requiring the <code class="language-plaintext highlighter-rouge">Self</code> type to be
sized, and hence writing <code class="language-plaintext highlighter-rouge">impl Foo for Foo</code> is illegal: the type <code class="language-plaintext highlighter-rouge">Foo</code>
is not sized and doesn’t implement <code class="language-plaintext highlighter-rouge">Sized</code>. Traits default to <code class="language-plaintext highlighter-rouge">Self</code>
being possibly-unsized—effectively a bound <code class="language-plaintext highlighter-rouge">Self: ?Sized</code>—to make
more traits object safe by default.</p>

<h3 id="by-value-self">By-value <code class="language-plaintext highlighter-rouge">self</code></h3>

<p><em>Update 2015-05-06</em>: this is no longer object unsafe, but it is
  impossible to call such methods on possibly-unsized types, including
  trait objects. That is, one can define traits with <code class="language-plaintext highlighter-rouge">self</code> methods,
  but one is statically disallowed from call those methods on trait
  objects (and on generics that could be trait objects).</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At the moment<sup id="fnref:change-is-in-the-air" role="doc-noteref"><a href="#fn:change-is-in-the-air" class="footnote" rel="footnote">1</a></sup>, it’s not possible to use trait
objects by-value anywhere, due to the lack of sizedness. If one were
to write an <code class="language-plaintext highlighter-rouge">impl Foo for Foo</code>, the signature of <code class="language-plaintext highlighter-rouge">method</code> would mean
<code class="language-plaintext highlighter-rouge">self</code> has type <code class="language-plaintext highlighter-rouge">Foo</code>: a by-value unsized type, illegal!</p>

<h3 id="static-method">Static method</h3>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There’s no way to provide a sensible implementation of <code class="language-plaintext highlighter-rouge">func</code> as a
static method on the type <code class="language-plaintext highlighter-rouge">Foo</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Foo</span><span class="o">+</span><span class="nv">'a</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">func</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="c">// what goes here??</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The compiler can’t just conjure up some <code class="language-plaintext highlighter-rouge">i32</code>—the chosen value may
make no sense in context—and it can’t call some other type’s
<code class="language-plaintext highlighter-rouge">Foo::func</code> method—which type would it choose? The whole scenario
makes no sense.</p>

<h3 id="references-self">References <code class="language-plaintext highlighter-rouge">Self</code></h3>

<p>There’s two fundamental ways in which this can happen, as an argument
or as a return value, in either case a reference to the <code class="language-plaintext highlighter-rouge">Self</code> type
means that it must match the type of the <code class="language-plaintext highlighter-rouge">self</code> value, the true type
of which is unknown at compile time. For example:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The types of the two arguments have to match, but this can’t be
guaranteed with a trait object: the erased types of two separate
<code class="language-plaintext highlighter-rouge">&amp;Foo</code> values may not match:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Foo</span><span class="o">+</span><span class="nv">'a</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">Foo</span><span class="o">+</span><span class="nv">'a</span><span class="p">))</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.vtable.method</span><span class="p">)(</span><span class="k">self</span><span class="py">.data</span><span class="p">,</span> <span class="cm">/* what goes here? */</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>(Using the explicit-but-invalid notation as above.)</p>

<p>One can’t use <code class="language-plaintext highlighter-rouge">other.data</code> because the <code class="language-plaintext highlighter-rouge">method</code> entry of <code class="language-plaintext highlighter-rouge">self.vtable</code>
is assuming that both pointers point to the same, specific type
(whatever type the vtable is specialised for), but there’s absolutely
no guarantee <code class="language-plaintext highlighter-rouge">other.data</code> points to matching data. There’s also not
necessarily a (reliable) way to detect a mismatch, and no way the
compiler can know a correct way to handle a mismatch even if it can be
detected.</p>

<h3 id="generic-method">Generic method</h3>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">method</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As discussed briefly in <a href="/blog/2015/01/peeking-inside-trait-objects/">the first post</a>, generic
functions in Rust are monomorphised, that is, a copy of the function
is created for each type used as a generic parameter. An attempted
implementation might look like</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Foo</span><span class="o">+</span><span class="nv">'a</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">method</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.vtable</span><span class="err">.</span><span class="cm">/* ... huh ???*/</span><span class="p">)(</span><span class="k">self</span><span class="py">.data</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The vtable is a static struct of function pointers, somehow we have to
select a function pointer from it that will work with the arbitrary
type <code class="language-plaintext highlighter-rouge">A</code>. To have any hope of doing this, one would have<sup id="fnref:alternative" role="doc-noteref"><a href="#fn:alternative" class="footnote" rel="footnote">2</a></sup>
to pregenerate code for every type that could possibly be used for <code class="language-plaintext highlighter-rouge">A</code>
and then fill in the <code class="language-plaintext highlighter-rouge">huh</code> above to select the right one. This would
be effectively implicitly adding a whole series of methods to the
trait:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">method_u8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>     <span class="c">// A = u8</span>
    <span class="k">fn</span> <span class="nf">method_i8</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>     <span class="c">// A = i8</span>
    <span class="k">fn</span> <span class="nf">method_String</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span> <span class="c">// A = String</span>
    <span class="k">fn</span> <span class="nf">method_unit</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>   <span class="c">// A = ()</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>and each one would need an entry in the vtable struct. If it is even
possible, this would be some serious bloat, especially as I imagine
most possibilities wouldn’t be used.</p>

<p>For the more fundamental question of “is it possible”, the answer is
rarely: it only works if the number of possible types that can be used
with the generic parameters is finite and completely known, so that a
complete list can be written. I think the only circumstance in which
this occurs is if all the parameters have to be bounded by some
private trait (the example above fails, since <code class="language-plaintext highlighter-rouge">A</code> is unbounded and so
can be used with every type ever, including ones that aren’t even
defined in scope).</p>

<section id="external-links" class="no-print">
  
  <div id="comments">
    <span class="external-label">Comments:</span>
    <ul class="external-list">
      

      
<li class="external-link"><a href="http://www.reddit.com/r/rust/comments/2s2okp/object_safety/">/r/rust</a></li>


      

      

      

      
    </ul>
  </div>
  
  <div id="external-page">
    <span class="external-label">Share this on</span>
    <ul class="external-list">
      <li class="external-link"><a href="https://bsky.app/intent/compose?text=Object%20Safety%20by%20@huonw.bsky.social%20https://huonw.github.io/blog/2015/01/object-safety/" target="_blank" rel="nofollow noopener" title="Share on Bluesky">Bluesky</a></li>
      <li class="external-link"><a href="https://twitter.com/intent/tweet?text=Object%20Safety%20%23rustlang&amp;url=https://huonw.github.io/blog/2015/01/object-safety/&amp;via=huon_w" target="_blank" rel="nofollow noopener" title="Share on Twitter">Twitter</a></li>
      <li class="external-link"><a href="https://facebook.com/sharer.php?u=https://huonw.github.io/blog/2015/01/object-safety/" rel="nofollow noopener" target="_blank" title="Share on Facebook">Facebook</a></li>
      <li class="external-link"><a href="https://www.reddit.com/submit?url=https://huonw.github.io/blog/2015/01/object-safety/&amp;title=Object%20Safety" rel="nofollow noopener" target="_blank" title="Share on Reddit">Reddit</a></li>
    </ul>
  </div>
</section>

<div class="footnotes" role="doc-endnotes">
  <ol start="0">
    <li id="fn:version" role="doc-endnote">
      <p><a href="/blog/2015/01/peeking-inside-trait-objects/">As usual</a>, this post is designed to reflect
        the state of Rust at version <code class="language-plaintext highlighter-rouge">rustc 1.0.0-nightly
        (44a287e6e 2015-01-08 17:03:40 -0800)</code>. <a href="#fnref:version" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:change-is-in-the-air" role="doc-endnote">
      <p>There is desire to remove/relax this
                     restriction for function parameters, and
                     especially <code class="language-plaintext highlighter-rouge">self</code>, to allow them to be
                     unsized types. Niko’s <a href="http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/">“Purging proc”</a>
                     describes the problem and the necessity for
                     <a href="http://doc.rust-lang.org/nightly/std/thunk/trait.Invoke.html">the <code class="language-plaintext highlighter-rouge">Invoke</code> trait</a> as a work-around
                     for the <code class="language-plaintext highlighter-rouge">FnOnce</code> trait. <a href="#fnref:change-is-in-the-air" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:alternative" role="doc-endnote">
      <p>Strictly speaking I suppose one could do some type of
            runtime codegen/JITing, but that’s not really
            something Rust wants to build into the language, as it
            would require Rust programs to essentially carry
            around a compiler. <a href="#fnref:alternative" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>

    
    <footer id="more" class="no-print">
      <div id="by-line">
  <a href="/about"><div class="no-print" id="me-icon"></div></a>

<p>I'm <a href="https://bsky.app/profile/huonw.bsky.social"><strong>Huon Wilson</strong></a>, a
 mathematically and statistically inclined software engineer.
 I have been a long-term volunteer
 on <a href="http://rust-lang.org">Rust</a>'s core team, a
 compiler engineer on the <a href="https://swift.org/">Swift</a> team
 at Apple, and a senior software engineer at CSIRO's Data61, working on the <a href="https://github.com/stellargraph/stellargraph">StellarGraph
 graph machine learning library</a>.
</p>
</div>
      <h2 id="latest-heading"><a href="/blog">Latest posts</a></h2>
      
      <nav>
        <ul id="latest-list"><!--
           
           --><li class="latest-post">
                <a href="/blog/2025/03/rust-fallthrough/">
                   <h3>Take a break: Rust match has fallthrough</h3>
                     <p>Match + labelled blocks &amp; breaks = fallthrough. It works, but it’s not very pretty!
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/03/ev-newtons/">
                   <h3>Newtons are a unit of mileage</h3>
                     <p>For an EV, Newtons (N) is a seemingly sensible version of L/100km or mpg, for measuring the efficiency of the car. Summing drag and rolling resistance forces aligns closely to real world observations.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/02/ci-tee/">
                   <h3>Prefer tee -a, not >>, in CI</h3>
                     <p><table>
  <tbody>
    <tr>
      <td>GitHub Actions suggests using code like echo … » $GITHUB_ENV, but echo …</td>
      <td>tee -a $GITHUB_ENV is often better.</td>
    </tr>
  </tbody>
</table>
</p>
                   
                 </a>
            </li><!--
          
      --></ul>
      </nav>
    </footer>
    
  </main>

  <footer id="page-footer">
    <span>Huon Wilson &mdash; <span class="date">2021</span></span>
  </footer>
</div>



<!-- Default Statcounter code for huonw.github.io
http://huonw.github.io -->
<script type="text/javascript">
var sc_project=7439209;
var sc_invisible=1;
var sc_security="b96244c7";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="hit counter"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/7439209/0/b96244c7/1/"
alt="hit counter"
referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
<!-- End of Statcounter Code -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62534856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-62534856-1');
</script>



</body> </html>
