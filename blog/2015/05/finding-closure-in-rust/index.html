<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>  Finding Closure in Rust |  Huon on the internet</title>

  <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Atom feed">
  <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RSS feed">
  
  <link rel="canonical" href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">

  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  

  
  <meta name="description" content="Closures in Rust are powerful and flexible, building on traits, generics and ownership.
" />

  
  <meta name="twitter:card" content="summary" />
  
  <meta name="twitter:site" content="@huon_w" />
  <meta name="twitter:title" content="Finding Closure in Rust" />
  <meta name="twitter:description" content="Closures in Rust are powerful and flexible, building on traits, generics and ownership.
" />
  <meta name="twitter:url" content="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">

  <!-- facebook -->
  <meta property="og:url" content="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/" />
  <meta property="og:title" content="Finding Closure in Rust" />
  <meta property="og:description" content="Closures in Rust are powerful and flexible, building on traits, generics and ownership.
" />
  
  <meta property="og:type" content="article" />
  
  
  
  <style>
    /*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}html{line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0;font-family:system-ui, -apple-system,'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type='button'],[type='reset'],[type='submit'],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}


    
      /* Borrowed from mojombo: https://github.com/mojombo/mojombo.github.com/blob/master/css/syntax.css */

.lineno { width: 2em; text-align:right; }
.highlight pre {
  white-space: pre;
}
.highlight .c { color: #777; font-style: italic; } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */


html {
    min-height:100%;
}

* {
  margin: 0;
}
* + * {
  margin-top: 0.75em;
}


body {
  padding:0px;
    counter-reset: footnotes;
    counter-reset: figure;
    margin:0px;
    font-size: 18px;
    background: white;
    color: #101010;

    font-variant: common-ligatures;
    -moz-font-feature-settings: "kern" on;
    -webkit-font-feature-settings: "kern" on;
    font-feature-settings: "kern" on;
}

#wrapper {
    margin: 0 auto;
    max-width: 630px;
    padding: 0.75em 15px;
    width: 100%;
    position:relative;
}

.lazily-filled {
  position: relative;
}
.lazily-filled > * {
  z-index: 0;
}
.lazily-filled::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgb(229, 236, 246);
  z-index: 1;
}
.lazily-filled::after {
  position: absolute;
  top: 50%;
  left: 50%;
  content: "";
  display: block;
  width: 128px;
  height: 128px;
  margin-left: -64px;
  margin-top: -64px;
  border-radius: 50%;
  border: 12px solid;
  border-color: white transparent;
  animation: spinner 5s linear;
  /* eventually stop animating when it's hidden */
  animation-iteration-count: 10;
  z-index: 2;
}
.lazily-filled::before, .lazily-filled::after {
  opacity: 0;
  transition: all 0.5s ease;
  pointer-events: none;
}
.lazily-filled:empty::before, .lazily-filled:empty::after {
  opacity: 1;
  animation-iteration-count: infinite;
  visibility: visible;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.plotly-plot * + * {
  margin-top: 0;
}

/* wonky safari */
.plotly text[style*="white-space: pre"] {
  white-space: nowrap !important;
}


/* lists */
li + li {
  margin-top: 0.5em;
}
ul, ol {
  padding-left: 1.5em;
}

table {
  margin-left: auto;
  margin-right: auto;
  border-collapse: collapse;
  text-align: left;
}

td, th {
  padding: 0.1em 0.75em;
}
@media (max-width: 500px) {
  td, th {
    padding-left: 0.375em;
    padding-right: 0.375em;
  }
}
tr:nth-child(even) {
  background: rgba(0, 0, 0, 5%);
}
thead {
  border-bottom: 1px solid grey;
  font-weight: bold;
}

header {
  margin-bottom: 1.5em;
}
header a:not(:hover) {
  text-decoration: none;
}
#blog-title {
  hyphens: none;
  font-variant: small-caps;
  font-size: 1.5em;
  font-weight: normal;
  text-align: center;
  line-height: 1em;
}
#info-list {
  list-style: none;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
}
#info-list li {
  margin: 0 1em;
}

#page-footer {
  border-top: 1px solid lightgrey;
  padding-top: 0.75em;
  color: grey;
  text-align: right;
}

.clear { clear: both; margin: 0; }


main {
    text-align:justify;
    -moz-hyphens: auto;
    -webkit-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
    line-height: 1.5em;

    position: relative;
    z-index: 10;
}

a[href] {
    color: inherit;
    text-decoration: underline;
}

/*  The authorship info */
#info-intro {
    font-style: italic;
    text-align: center;
}

/* code */

code, pre {
  font-family: monospace;
  font-variant: none;
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre {
  background: #f0f0f0;
}
code {
    background: #f7f7f7;
    padding: 0 0.1em;
    font-size: 0.9em;
    border-radius: 3px;
    border: 1px solid lightgrey;
}
pre code {
    background: none;
    padding: 0;
    -moz-hyphens: none;
    -webkit-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    border-radius: 0;
    border-width: 0;
}
h1 code, h2 code, h3 code, h4 code {
  background: rgba(255,255,255,0.1);
}

.break-all {
  word-break: break-all;
}

/* quotes and similar */

blockquote {
    border: solid #eee;
    border-width: 0 1px;
    padding: 0 1.2em;
    color: #444;
    position: relative;
    margin-left: 0;
    margin-right: 0;
}

aside {
  padding: 0 1.2em;
  color: #444;
  position: relative;
}
aside[data-icon] {
  padding-left: 2.4em;
}
aside[data-icon]:before {
  content: attr(data-icon);
  position: absolute;
  left: 0;
  text-align: center;
  width: 2.4em;
}

/* images/figures */
img, figure svg {
  max-width: 100%;
  height: auto;
}
figure svg {
  width: 100%;
}
img:not(.inline-image), figure svg {
    display: block;
    margin: 0 auto;
    clear: both;
}

.image-positioner {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

img[data-caption]:before {
    content: attr(data-caption);
}
figure {
  clear: both;
}
figure.image {
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;

  min-width: 100%;
}
figcaption {
  margin: 0 auto;
  max-width: 570px;
  padding: 0 10px;
  text-align: center;
  font-style: italic;
  font-size: 0.9em;
}
figcaption p {
  display: inline;
}
figcaption::before {
  counter-increment: figure;
  content: "Figure " counter(figure) ". ";
}

.highlight table {
  font-size: 0.9em;
  padding: 0em;
  width: 100%;
  table-layout: fixed;
  overflow-y: hidden;
  display: block;
  position: relative;
  z-index: 1;
}
[data-lang] {
  position: relative;
  display: block;
}
[data-lang]::before {
  content: attr(data-lang);
  text-transform: capitalize;
  top: 0;
  right: 0;
  position: absolute;
  font-size: 1.5em;
  color: #f3f3f3;
  z-index: 1;
}

.highlight pre {
  background: transparent;
}
.gutter {
  padding: 0;
  border: solid #ccc;
  border-width: 0 1px 0 0;
  color: #ccc;
}
.lineno {
  width: 25px;
  padding-right: 5px;
}
.highlight td.code {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}


/* HEADINGS */

h1, h2 {
    font-variant: small-caps;
}

h1, h2, h3, h4 {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
  text-align: left;
}

h1 {
  font-size: 2.2em;
  text-align: center;
  line-height: 1em;
}
h2 {
  font-size: 1.7em;
}
h3 {
  font-size: 1.4em;
}
h4 {
  font-size: 1.2em;
}

/* crates.io badges */

.lib-info {
  float: right;
  width: 150px;
  text-align: center;
  margin: 0 1em;
}
.lib-badge {
  vertical-align: middle;
}
.centered-libs {
  text-align: center;
}
.centered-libs .lib-info {
  float: none;
}

/* external links */

#external-links {
  margin-top: 2.25em;
  text-align: center;
}
.external-label {
  font-weight: bold;
}
#external-links ul {
  list-style: none;
  display: inline-block;
  padding: 0;
  margin: 0;
}
#external-links li {
  list-style: none;
  display: inline;
}

/* "Footnotes" */

/* the div that holds them */
.footnotes {
    margin-top: 2.25em;
    padding-top: 1.5em;
    border-top: 1px solid rgb(240,240,240);
    font-size: 0.9em;
}
.footnotes ol {
  padding: 0;
}
.footnotes li {
    list-style-position: outside;
    margin-left: 30px;
    margin-right: 10px;
    color: #333;
}

.footnotes li:target, .footnotes li:hover {
    color: black;
    background-color: lightyellow;
}

.footnotes .reversefootnote {
    text-decoration: none;
}

/* extra info after a post */
#more {
  margin-top: 3em;
  padding-top: 1.5em;
  border-top: 1px solid lightgray;
}
#me-icon {
  max-width: 150px;
  height: 150px;
  background: url("/img/me.jpg");
  background-size: cover;
  margin-left: auto;
  margin-right: auto;
  border-radius: 30px;
}
#by-line {
  font-size: 0.8em;
}
#latest-list {
  padding: 0;
  list-style: none;
}
#latest-heading {
  text-align: center;
}
#latest-heading a:not(:hover) {
  text-decoration: none;
}
#latest-list a:hover h3 {
  text-decoration: underline;
}
#latest-list a {
  text-decoration: none;
}
.latest-post {
  padding: 0;
  font-size: 0.8em;
}
.latest-post > h3 {
  font-weight: bold;
}
.latest-post * {
  margin: 0;
}

/* post series */

.post-series {
  font-size: 0.8em;
  border: 1px solid lightgray;
  padding: 0.2em;
  cursor: pointer;
}

.post-series-title {
  font-weight: bold;
  font-size: 1.1em;
}
.post-series-list {
  padding-left: 1.5em;
  margin: 0;
}
.post-series .current {
  font-style: italic;
}

/* archive pages */
ul.post-list {
  list-style: none;
  padding: 0;
}

.post-post {
  margin: 0;
}

.post-post + .post-post {
  border-top: 1px dashed  #ddd;
  margin-top: 1em;
  padding-top: 1em;
}

a.post-heading {
  display: flex;
  align-items: baseline;
  text-decoration: none;
  gap: 1em;
}
.post-heading * {
  margin: 0;
}

.post-title {
  font-size: 1.2em;
  flex-grow: 1;
  text-decoration: underline;
}

.post-heading .post-date {
  font-style: italic;
  flex-shrink: 0;
}

.post-excerpt p {
  display: inline;
}

.post-more {
  font-style: italic;
  white-space: nowrap;
  float: right;
  margin: 0;
  font-size: smaller;
}

.post-list .footnote, .post-list .footnotes, .post-list p:empty {
  display: none
}

/* media queries */


@media only print {
    a {
      text-decoration: none !important;
    }
    header {
        display:none !important;
    }

    h1, h2, h3, h4 {
        padding-left: 0 !important;
    }

    #wrapper {
       max-width: none !important;
    }

    .no-print {
        display: none !important;
    }

    .footnotes .reversefootnote {
         display: none !important;
    }
    [data-lang]::before {
      content: "";
    }
}

    

    
  </style>
  
</head>

<body>
<div id="wrapper">
  <header>
    <h1 id="blog-title"><a href="/">Huon on the internet</a></h1>
    <nav>
      <ul id="info-list" class="no-print">
        <li><a href="/about">About</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="https://github.com/huonw">GitHub</a></li>
        <li><a href="https://bsky.app/profile/huonw.bsky.social">Bluesky</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
      
        <h1 id="title"> Finding Closure in Rust</h1>
        
      
      
         <div id="info-intro">
           By <a href="/about">Huon Wilson</a>
           
             &mdash; <span class="date pub-date">08 May 2015</span>
           
           
         </div>
      
      <p>Have you ever used an <a href="http://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator adapter</a> in <a href="http://rust-lang.org">Rust</a>?
Called a method on <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code class="language-plaintext highlighter-rouge">Option</code></a>? <a href="http://doc.rust-lang.org/std/thread/fn.spawn.html">Spawned</a> a thread?
You’ve almost certainly used a <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">closure</a>. The design in Rust may seem
a little complicated, but it slides right into Rust’s normal ownership
model so let’s reinvent it from scratch.</p>

<p>The new design was introduced in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md">RFC 114</a>, moving Rust to a
model for closures similar to C++11’s. The design builds on Rust’s
standard trait system to allow for allocation-less
statically-dispatched closures, but also giving the choice to opt-in
to type-erasure and dynamic dispatch and the benefits that brings. It
incorporates elements of inference that “just work” by ensuring that
ownership works out.</p>

<blockquote>
  <p>Steve Klabnik has written
<a href="http://doc.rust-lang.org/book/closures.html">some docs on Rust’s closures</a> for the official
documentation. I’ve explicitly avoided reading it so far because
I’ve always wanted to write this, and I think it’s better to give a
totally independent explanation while I have the chance. If
something is confusing here, maybe they help clarify.</p>
</blockquote>

<h2 id="whats-a-closure">What’s a closure?</h2>

<p>In a sentence: a closure is a function that can directly use variables
from the scope in which it is defined. This is often described as the
closure <em>closing over</em> or <em>capturing</em> variables (the
<em>captures</em>). Collectively, the variables are called the <em>environment</em>.</p>

<p>Syntactically, a closure in Rust is an anonymous function<sup id="fnref:anon" role="doc-noteref"><a href="#fn:anon" class="footnote" rel="footnote">0</a></sup> value
defined a little like Ruby, with pipes: <code class="language-plaintext highlighter-rouge">|arguments...| body</code>. For
example, <code class="language-plaintext highlighter-rouge">|a, b| a + b</code> defines a closure that takes two arguments and
returns their sum. It’s just like a normal function declaration, with
more inference:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c">// function:</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="c">// closure:</span>
      <span class="p">|</span><span class="n">a</span><span class="p">,</span>      <span class="n">b</span><span class="p">|</span>               <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Just like a normal function, they can be called with parentheses:
<code class="language-plaintext highlighter-rouge">closure(arguments...)</code>.</p>

<p>To illustrate the capturing, this code snippet calls
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code class="language-plaintext highlighter-rouge">map</code></a> on an <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code>, which will call a closure on
the <code class="language-plaintext highlighter-rouge">i32</code> (if it exists) and create a new <code class="language-plaintext highlighter-rouge">Option</code> containing the
return value of the call.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">option</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c">// explicit types:</span>
    <span class="k">let</span> <span class="n">new</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">option</span><span class="nf">.map</span><span class="p">(|</span><span class="n">val</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="n">val</span> <span class="o">+</span> <span class="n">x</span> <span class="p">});</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span> <span class="c">// Some(5)</span>

    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c">// inferred:</span>
    <span class="k">let</span> <span class="n">new2</span> <span class="o">=</span> <span class="n">option</span><span class="nf">.map</span><span class="p">(|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">new2</span><span class="p">);</span> <span class="c">// Some(20)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The closures are capturing the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> variables, allowing them to
be used while mapping. (To be more convincing, imagine they were only
known at runtime, so that one couldn’t just write <code class="language-plaintext highlighter-rouge">val + 3</code> inside the
closure.)</p>

<h2 id="back-to-basics">Back to basics</h2>

<p>Now that we have the semantics in mind, take a step back and riddle me
this: how would one implement that sort of generic <code class="language-plaintext highlighter-rouge">map</code> if Rust
didn’t have closures?</p>

<p>The functionality of <code class="language-plaintext highlighter-rouge">Option::map</code> we’re trying to duplicate is (equivalently):</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">option</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">transformer</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="c">// (closure syntax for now)</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We need to fill in the <code class="language-plaintext highlighter-rouge">...</code> with something that transforms an <code class="language-plaintext highlighter-rouge">X</code> into
a <code class="language-plaintext highlighter-rouge">Y</code>. The biggest constraint for perfectly replacing <code class="language-plaintext highlighter-rouge">Option::map</code> is
that it needs to be generic in some way, so that it works with
absolutely any way we wish to do the transformation. In Rust, that
calls for a generic bounded by a trait.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="cm">/* the trait */</span>
<span class="p">{</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This trait needs to have a method that converts some specific type
into another. Hence there’ll have to be form of type parameters to
allow the exact types to be specified in generic bounds like
<code class="language-plaintext highlighter-rouge">map</code>. There’s two choices: generics in the trait definition (“input
type parameters”) and associated types (“output type parameters”). The
quoted names hint at the choices we should take: the type that gets
input into the transformation should be a generic in the trait, and
the type that is output by the transformation should be an associated
type.<sup id="fnref:assoc-vs-not" role="doc-noteref"><a href="#fn:assoc-vs-not" class="footnote" rel="footnote">1</a></sup></p>

<p>So, our trait looks something like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Transform</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">transform</span><span class="p">(</span><span class="cm">/* self?? */</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="n">Input</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The last question is what sort of <code class="language-plaintext highlighter-rouge">self</code> (if any) the method should
take?</p>

<p>The transformation should be able to incorporate arbitrary information
beyond what is contained in <code class="language-plaintext highlighter-rouge">Input</code>. Without any <code class="language-plaintext highlighter-rouge">self</code> argument, the
method would look like <code class="language-plaintext highlighter-rouge">fn transform(input: Input) -&gt; Self::Output</code>
and the operation could only depend on <code class="language-plaintext highlighter-rouge">Input</code> and global
variables (ick). So we do need one.</p>

<p>The most obvious options are by-reference <code class="language-plaintext highlighter-rouge">&amp;self</code>,
by-mutable-reference <code class="language-plaintext highlighter-rouge">&amp;mut self</code>, or by-value <code class="language-plaintext highlighter-rouge">self</code>. We want to allow
the users of <code class="language-plaintext highlighter-rouge">map</code> to have as much power as possible while still
enabling <code class="language-plaintext highlighter-rouge">map</code> to type-check. At a high-level <code class="language-plaintext highlighter-rouge">self</code> gives
<em>implementers</em> (i.e. the types users define to implement the trait)
the most flexibility, with <code class="language-plaintext highlighter-rouge">&amp;mut self</code> next and <code class="language-plaintext highlighter-rouge">&amp;self</code> the least
flexible. Conversely, <code class="language-plaintext highlighter-rouge">&amp;self</code> gives <em>consumers</em> of the trait
(i.e. functions with generics bounded by the trait) the most
flexibility, and <code class="language-plaintext highlighter-rouge">self</code> the least.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right"> </th>
      <th><strong>Implementer</strong></th>
      <th><strong>Consumer</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">self</code></td>
      <td>Can move out and mutate</td>
      <td>Can only call method once</td>
    </tr>
    <tr>
      <td style="text-align: right"><code>&amp;mut&nbsp;self</code></td>
      <td>Can’t move out, can mutate</td>
      <td>Can call many times, only with unique access</td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">&amp;self</code></td>
      <td>Can’t move out or mutate</td>
      <td>Can call many times, with no restrictions</td>
    </tr>
  </tbody>
</table>

<div class="join"></div>

<p>(“Move out” and “mutate” in the implementer column are referring to data stored inside <code class="language-plaintext highlighter-rouge">self</code>.)</p>

<p>Choosing between them is a balance, we usually want to chose the
highest row of the table that still allows the consumers to do what
they need to do, as that allows the external implementers to do as
much as possible.</p>

<p>Starting at the top of that table: we can try <code class="language-plaintext highlighter-rouge">self</code>. This gives <code class="language-plaintext highlighter-rouge">fn
transform(self, input: Input) -&gt; Self::Output</code>. The by-value <code class="language-plaintext highlighter-rouge">self</code>
will consume ownership, and hence <code class="language-plaintext highlighter-rouge">transform</code> can only be called
once. Fortunately, <code class="language-plaintext highlighter-rouge">map</code> only needs to do the transformation once, so
by-value <code class="language-plaintext highlighter-rouge">self</code> works perfectly.</p>

<p>In summary, our <code class="language-plaintext highlighter-rouge">map</code> and its trait look like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Transform</span><span class="o">&lt;</span><span class="n">Input</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">transform</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="n">Input</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">option</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Transform</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">match</span> <span class="n">option</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">transform</span><span class="nf">.transform</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The example from before can then be reimplemented rather verbosely, by
creating structs and implementing <code class="language-plaintext highlighter-rouge">Transform</code> to do the appropriate
conversion for that struct.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="c">// replacement for |val| val + x</span>
<span class="k">struct</span> <span class="n">Adder</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">}</span>

<span class="k">impl</span> <span class="n">Transform</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Adder</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="c">// ignoring the `fn ... self`, this looks similar to |val| val + x</span>
    <span class="k">fn</span> <span class="nf">transform</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="n">val</span> <span class="o">+</span> <span class="k">self</span><span class="py">.x</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// replacement for |val| val * y</span>
<span class="k">struct</span> <span class="n">Multiplier</span> <span class="p">{</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">}</span>

<span class="k">impl</span> <span class="n">Transform</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Multiplier</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="c">// looks similar to |val| val * y</span>
    <span class="k">fn</span> <span class="nf">transform</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="n">val</span> <span class="o">*</span> <span class="k">self</span><span class="py">.y</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">option</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">new</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">Adder</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="p">});</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span> <span class="c">// Some(5)</span>

    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">new2</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">Multiplier</span> <span class="p">{</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="p">});</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">new2</span><span class="p">);</span> <span class="c">// Some(20)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We’ve manually implemented something that seems to have the same
semantics as Rust closures, using traits and some structs to store and
manipulate the captures. In fact, the struct has some uncanny
similarities to the “environment” of a closure: it stores a pile of
variables that need to be used in the body of <code class="language-plaintext highlighter-rouge">transform</code>.</p>

<h2 id="how-do-real-closures-work">How do real closures work?</h2>

<p>Just like that, plus a little more flexibility and syntactic
sugar. The real definition of <code class="language-plaintext highlighter-rouge">Option::map</code> is:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">F</span><span class="p">:</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Y</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">FnOnce(X) -&gt; Y</code> is another name for our <code class="language-plaintext highlighter-rouge">Transform&lt;X, Output = Y&gt;</code>
bound, and, <code class="language-plaintext highlighter-rouge">f(x)</code> for <code class="language-plaintext highlighter-rouge">transform.transform(x)</code>.</p>

<p>There are three traits for closures, all of which provide the
<code class="language-plaintext highlighter-rouge">...(...)</code> call syntax (one could regard them as different kinds of
<code class="language-plaintext highlighter-rouge">operator()</code> in C++). They differ only by the <code class="language-plaintext highlighter-rouge">self</code> type of the call
method, and they cover all of the <code class="language-plaintext highlighter-rouge">self</code> options listed above.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.Fn.html"><code class="language-plaintext highlighter-rouge">Fn</code></a></li>
  <li><code class="language-plaintext highlighter-rouge">&amp;mut self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code class="language-plaintext highlighter-rouge">FnMut</code></a></li>
  <li><code class="language-plaintext highlighter-rouge">self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code class="language-plaintext highlighter-rouge">FnOnce</code></a></li>
</ul>

<p>These traits are covering exactly the three core ways to handle data
in Rust, so having each of them meshes perfectly with Rust’s
type-system.</p>

<p>When you write <code class="language-plaintext highlighter-rouge">|args...| code...</code> the compiler will implicitly define
a unique new struct type storing the captured variables, and then
implement one of those traits using the closure’s body, rewriting any
mentions of captured variables to go via the closure’s
environment. The struct type doesn’t have a user visible name, it is
purely internal to the compiler. When the program hits the closure
definition at runtime, it fills in an instance of struct and passes
that instance into whatever it needs to (like we did with our <code class="language-plaintext highlighter-rouge">map</code>
above).</p>

<p>There’s two questions left:</p>

<ol>
  <li>how are variables captured? (what type are the fields of the environment struct?)</li>
  <li>which trait is used? (what type of <code class="language-plaintext highlighter-rouge">self</code> is used?)</li>
</ol>

<p>The compiler answers both by using some local rules to choose the
version that will give the most flexibility. The local rules are
designed to be able to be checked only knowing the definition
the closure, and the types of any variables it captures.<sup id="fnref:i-think" role="doc-noteref"><a href="#fn:i-think" class="footnote" rel="footnote">2</a></sup></p>

<p>By “flexibility” I mean the compiler chooses the option that (it
thinks) will compile, but imposes the least on the programmer.</p>

<h3 id="structs-and-captures">Structs and captures</h3>

<p>If you’re familiar with closures in C++11, you may recall the <code class="language-plaintext highlighter-rouge">[=]</code>
and <code class="language-plaintext highlighter-rouge">[&amp;]</code> capture lists: capture variables by-value<sup id="fnref:copy" role="doc-noteref"><a href="#fn:copy" class="footnote" rel="footnote">3</a></sup> and
by-reference respectively. Rust has similar capability: variables can
be captured by-value—the variable is moved into the closure
environment—or by-reference—a reference to the variable is stored
in the closure environment.</p>

<p>By default, the compiler looks at the closure body to see how captured
variables are used, and uses that to infers how variables should be
captured:</p>

<ul>
  <li>if a captured variable is only ever used through a shared reference,
it is captured by <code class="language-plaintext highlighter-rouge">&amp;</code> reference,</li>
  <li>if it used through a mutable reference (including assignment), it is
captured by <code class="language-plaintext highlighter-rouge">&amp;mut</code> reference,</li>
  <li>if it is moved, it is forced to be captured by-value. (NB. using a
<a href="http://doc.rust-lang.org/std/marker/trait.Copy.html"><code class="language-plaintext highlighter-rouge">Copy</code></a> type
by-value only needs a <code class="language-plaintext highlighter-rouge">&amp;</code> reference, so this rule only applies to
non-<code class="language-plaintext highlighter-rouge">Copy</code> ones.)</li>
</ul>

<p>The algorithm seems a little non-trivial, but it matches exactly the
mental model of a practiced Rust programmer, using ownership/borrows
as precisely as it can. In fact, if a closure is “non-escaping”, that
is, never leaves the stack frame in which it is created, I believe
this algorithm is perfect: code will compile without needing any
annotations about captures.</p>

<p>To summarise, the compiler will capture variables in the way that is
least restrictive in terms of continued use outside the closure (<code class="language-plaintext highlighter-rouge">&amp;</code>
is preferred, then <code class="language-plaintext highlighter-rouge">&amp;mut</code> and lastly by-value), and that still works
for all their uses within the closure. This analysis happens on a
per-variable basis, e.g.:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">T</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">fn</span> <span class="nf">by_value</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">by_mut</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="mi">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">z</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>

    <span class="c">// forces `y` and `z` to be at least captured by `&amp;mut` reference</span>
    <span class="nf">by_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span><span class="p">);</span>
    <span class="nf">by_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">z</span><span class="p">);</span>

    <span class="c">// forces `z` to be captured by value</span>
    <span class="nf">by_value</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To focus on the flexibility: since <code class="language-plaintext highlighter-rouge">x</code> is only captured by shared
reference, it is legal for it be used while <code class="language-plaintext highlighter-rouge">closure</code> exists, and
since <code class="language-plaintext highlighter-rouge">y</code> is borrowed (by mutable reference) it can be used once
<code class="language-plaintext highlighter-rouge">closure</code> goes out of scope, but <code class="language-plaintext highlighter-rouge">z</code> cannot be used at all, even once
<code class="language-plaintext highlighter-rouge">closure</code> is gone, since it has been moved into the <code class="language-plaintext highlighter-rouge">closure</code> value.</p>

<p>The compiler would create code that looks a bit like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="nv">'x</span><span class="p">,</span> <span class="nv">'y</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'x</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'y</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">T</span>
<span class="p">}</span>

<span class="cm">/* impl of FnOnce for Environment */</span>

<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="n">Environment</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">z</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The struct desugaring allows the full power of Rust’s type system is
brought to bear on ensuring it isn’t possible to accidentally get a
dangling reference or use freed memory or trigger any other memory
safety violation by misusing a closure. If there is problematic code,
the compiler will point it out.</p>

<h3 id="move-and-escape"><code class="language-plaintext highlighter-rouge">move</code> and escape</h3>

<p>I stated above that the inference is perfect for non-escaping
closures… which implies that it is not perfect for “escaping” ones.</p>

<p>If a closure is escaping, that is, if it might leave the stack frame
where it is created, it must not contain any references to values
inside that stack frame, since those references would be dangling when
the closure is used outside that frame: very bad. Fortunately the
compiler will emit an error if there’s a risk of that, but returning
closures can be useful and so should be possible; for example<sup id="fnref:trait-object" role="doc-noteref"><a href="#fn:trait-object" class="footnote" rel="footnote">4</a></sup>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c">/// Returns a closure that will add `x` to its argument.</span>
<span class="k">fn</span> <span class="nf">make_adder</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">y</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">make_adder</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c">// 4</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">f</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="c">// 13</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<div class="join"></div>

<p>Looks good, except… it doesn’t actually compile:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>...:3:14: 3:23 error: closure may outlive the current function, but it borrows `x`, which is owned by the current function [E0373]
...:3     Box::new(|y| x + y)
                   ^~~~~~~~~
...:3:18: 3:19 note: `x` is borrowed here
...:3     Box::new(|y| x + y)
                       ^
</pre></td></tr></tbody></table></code></pre></figure>

<p>The problem is clearer when everything is written as explicit structs:
<code class="language-plaintext highlighter-rouge">x</code> only needs to be captured by reference to be used with <code class="language-plaintext highlighter-rouge">+</code>, so the
compiler is inferring that the code can look like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Closure</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">i32</span>
<span class="p">}</span>

<span class="cm">/* impl of Fn for Closure */</span>

<span class="k">fn</span> <span class="nf">make_adder</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Closure</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">x</code> goes out of scope at the end of <code class="language-plaintext highlighter-rouge">make_adder</code> so it is illegal to
return something that holds a reference to it.</p>

<p>So how do we fix it? Wouldn’t it be nice if the compiler could tell
us…</p>

<p>Well, actually, I omitted the last two lines of the error message above:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>...:3:14: 3:23 help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword, as shown:
...:      Box::new(move |y| x + y)
</pre></td></tr></tbody></table></code></pre></figure>

<p>A new keyword! The <code class="language-plaintext highlighter-rouge">move</code> keyword can be placed in front of a closure
declaration, and overrides the inference to capture all variables by
value. Going back to the previous section, if the code used <code class="language-plaintext highlighter-rouge">let
closure = move || { /* same code */ }</code> the environment struct would
look like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Environment</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">T</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Capturing entirely by value is also strictly more general than
capturing by reference: the reference types are first-class in Rust,
so “capture by reference” is the same as “capture a reference by
value”. Thus, unlike C++, there’s little fundamental distinction
between capture by reference and by value, and the analysis Rust does
is not actually <em>necessary</em>: it just makes programmers’ lives easier.</p>

<p>To demonstrate, the following code will have the same behaviour and
same environment as the first version, by capturing references using
<code class="language-plaintext highlighter-rouge">move</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">z</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

<span class="k">let</span> <span class="n">x_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="k">let</span> <span class="n">y_mut</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span><span class="p">;</span>

<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="n">x_ref</span><span class="p">);</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">y_mut</span><span class="p">);</span>
    <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>

    <span class="nf">by_mut</span><span class="p">(</span><span class="n">y_mut</span><span class="p">);</span>
    <span class="nf">by_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">z</span><span class="p">);</span>

    <span class="nf">by_value</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The set of variables that are captured is exactly those that are used
in the body of the closure, there’s no fine-grained capture lists like
in C++11. The <code class="language-plaintext highlighter-rouge">[=]</code> capture list exists as the <code class="language-plaintext highlighter-rouge">move</code> keyword, but
that is all.</p>

<p>We can now solve the original problem of returning from <code class="language-plaintext highlighter-rouge">make_adder</code>:
by writing <code class="language-plaintext highlighter-rouge">move</code> we force the compiler to avoid any
implicit/additional references, ensuring that the closure isn’t tied
to the stack frame of its birth. If we take the compiler’s suggestion
and write <code class="language-plaintext highlighter-rouge">Box::new(move |y| x + y)</code>, the code inside the compiler
will look more like:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Closure</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span>
<span class="p">}</span>

<span class="cm">/* impl of Fn for Closure */</span>

<span class="k">fn</span> <span class="nf">make_adder</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Closure</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It is clear that the compiler doesn’t infer when <code class="language-plaintext highlighter-rouge">move</code> is required
(or else we wouldn’t need to write it), but the fact that the <code class="language-plaintext highlighter-rouge">help</code>
message exists suggests that the compiler does know enough to infer
when <code class="language-plaintext highlighter-rouge">move</code> is necessary or not… in some cases. Unfortunately, doing
so in general in a reliable way (a <code class="language-plaintext highlighter-rouge">help</code> message can be
heuristic/best-effort, but inference built into the language cannot
be), would require more than just an analysis of the internals of the
closure body: it would require more complicated machinery to look at
how/where the closure value is used.</p>

<h3 id="traits">Traits</h3>

<p>The actual “function” bit of closures are handled by the traits
mentioned above. The implicit struct types will also have implicit
implementations of some of those traits, exactly those traits that
will actually work for the type.</p>

<p>Let’s start with an example: for the <code class="language-plaintext highlighter-rouge">make_adder</code> example, the <code class="language-plaintext highlighter-rouge">Fn</code>
trait is implemented for the implicit closure struct:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c">// (this is just illustrative, see the footnote for the gory details)</span>
<span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="k">for</span> <span class="n">Closure</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="c">// |y|   x + y</span>
        <span class="k">self</span><span class="py">.x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In reality, there are also implicit implementations<sup id="fnref:invalid" role="doc-noteref"><a href="#fn:invalid" class="footnote" rel="footnote">5</a></sup> of
<code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">FnOnce</code> for <code class="language-plaintext highlighter-rouge">Closure</code>, but <code class="language-plaintext highlighter-rouge">Fn</code> is the “fundamental” one
for this closure.</p>

<p>There’s three traits, and so seven non-empty sets of traits that <em>could</em><sup id="fnref:inherit" role="doc-noteref"><a href="#fn:inherit" class="footnote" rel="footnote">6</a></sup> possibly be
implemented… but there’s actually only three interesting
configurations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">FnOnce</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">FnOnce</code>,</li>
  <li>only <code class="language-plaintext highlighter-rouge">FnOnce</code>.</li>
</ul>

<p>Why? Well, the three closure traits are actually three nested sets:
every closure that implements <code class="language-plaintext highlighter-rouge">Fn</code> can also implement <code class="language-plaintext highlighter-rouge">FnMut</code> (if
<code class="language-plaintext highlighter-rouge">&amp;self</code> works, <code class="language-plaintext highlighter-rouge">&amp;mut self</code> also works; proof: <code class="language-plaintext highlighter-rouge">&amp;*self</code>), and similarly
every closure implementing <code class="language-plaintext highlighter-rouge">FnMut</code> can also implement <code class="language-plaintext highlighter-rouge">FnOnce</code>. This
hierarchy is enforced at the type level,
e.g. <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code class="language-plaintext highlighter-rouge">FnMut</code></a>
has declaration:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<div class="join"></div>
<p>In words: anything that implements <code class="language-plaintext highlighter-rouge">FnMut</code> <em>must</em> also implement
<code class="language-plaintext highlighter-rouge">FnOnce</code>.</p>

<p>There’s no subtlety required when inferring what traits to implement
as the compiler can and will just implement <em>every</em> trait for which
the implementation is legal. This is in-keeping with the “offer
maximum flexibility” rule that was used for the inference of the
capture types, since more traits means more options. The subset nature
of the <code class="language-plaintext highlighter-rouge">Fn*</code> traits means that following this rule will always result
in one of the three sets listed above being implemented.</p>

<p>As an example, this code demonstrates a closure for which an
implementation of <code class="language-plaintext highlighter-rouge">Fn</code> is illegal but both <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">FnOnce</code> are
fine.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

<span class="c">// nice form</span>
<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">||</span> <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c">// explicit form</span>
<span class="k">struct</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="nv">'v</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'v</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="c">// let's try implementing `Fn`</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'v</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">()</span> <span class="k">for</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="nv">'v</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.v</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c">// error: cannot borrow data mutably</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="n">Environment</span> <span class="p">{</span> <span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It is illegal to mutate via a <code class="language-plaintext highlighter-rouge">&amp; &amp;mut ...</code>, and <code class="language-plaintext highlighter-rouge">&amp;self</code> is creating
that outer shared reference. If it was <code class="language-plaintext highlighter-rouge">&amp;mut self</code> or <code class="language-plaintext highlighter-rouge">self</code>, it would
be fine: the former is more flexible, so the compiler implements
<code class="language-plaintext highlighter-rouge">FnMut</code> for <code class="language-plaintext highlighter-rouge">closure</code> (and also <code class="language-plaintext highlighter-rouge">FnOnce</code>).</p>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">closure</code> was to be <code class="language-plaintext highlighter-rouge">|| drop(v);</code>—that is, move out of
<code class="language-plaintext highlighter-rouge">v</code>—it would be illegal to implement either <code class="language-plaintext highlighter-rouge">Fn</code> or <code class="language-plaintext highlighter-rouge">FnMut</code>, since
the <code class="language-plaintext highlighter-rouge">&amp;self</code> (respectively <code class="language-plaintext highlighter-rouge">&amp;mut self</code>) means that the method would be
trying to steal ownership out of borrowed data: criminal.</p>

<h2 id="flexibility">Flexibility</h2>

<p>One of Rust’s goals is to leave choice in the hands of the programmer,
allowing their code to be efficient, with abstractions compiling away
and just leaving fast machine code. The design of closures to use
unique struct types and traits/generics is key to this.</p>

<p>Since each closure has its own type, there’s no compulsory need for
heap allocation when using closures: as demonstrated above, the
captures can just be placed directly into the struct value. This is a
property Rust shares with C++11, allowing closures to be used in
essentially any environment, including bare-metal environments.</p>

<p>The unique types does mean that one can’t use different closures
together automatically, e.g. one can’t create a vector of several
distinct closures. They may have different sizes and require different
invocations (different closures correspond to different internal code,
so a different function to call). Fortunately, the use of traits to
abstract over the closure types means one can opt-in to these features
and their benefits “on demand”, via <a href="/blog/2015/01/peeking-inside-trait-objects/">trait objects</a>: returning
the <code class="language-plaintext highlighter-rouge">Box&lt;Fn(i32) -&gt; i32&gt;</code> above used a trait object.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">text</span> <span class="o">=</span> <span class="s">"second"</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">closures</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

<span class="n">closures</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"first"</span><span class="p">)));</span>
<span class="n">closures</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">text</span><span class="p">)));</span>
<span class="n">closures</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"third"</span><span class="p">)));</span>

<span class="k">for</span> <span class="n">f</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">closures</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">();</span> <span class="c">// first / second / third</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>An additional benefit to the approach of unique types and generics
means that, by default, the compiler has full information about what
closure calls are doing at each call site, and so has the choice to
perform key optimisations like inlining. For example, the following
snippets compile to the same code,</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">x</span><span class="nf">.map</span><span class="p">(|</span><span class="n">z</span><span class="p">|</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

<span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<div class="join"></div>

<p>(When I tested it by placing them into separate functions in a single
binary, the compiler actually optimised the second function to a
direct call to the first.)</p>

<p>This is all due to how Rust implements generics via monomorphisation,
where generic functions are compiled for each way their type
parameters are chosen, explicitly substituting the generic type with a
concrete one. Unfortunately, this isn’t always an optimisation, as it
can result in code bloat, where there are many similar copies of a
single function, which is again something that trait objects can
tackle: by using a trait object instead, one can use dynamically
dispatched closures to ensure there’s only one copy of a function,
even if it is used with many different closures.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">generic_closure</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">generic_closure</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span> <span class="c">// A</span>
<span class="nf">generic_closure</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="p">{</span> <span class="c">// B</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">});</span>


<span class="k">fn</span> <span class="nf">closure_object</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">))</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">closure_object</span><span class="p">(</span><span class="o">&amp;</span><span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>
<span class="nf">closure_object</span><span class="p">(</span><span class="o">&amp;</span><span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The final binary will have two copies of <code class="language-plaintext highlighter-rouge">generic_closure</code>, one for
<code class="language-plaintext highlighter-rouge">A</code> and one for <code class="language-plaintext highlighter-rouge">B</code>, but only one copy of <code class="language-plaintext highlighter-rouge">closure_object</code>. In fact,
there are implementations of the <code class="language-plaintext highlighter-rouge">Fn*</code> traits for pointers, so one can
even use a trait object directly with <code class="language-plaintext highlighter-rouge">generic_closure</code>,
e.g. <code class="language-plaintext highlighter-rouge">generic_closure((&amp;|x| { ... }) as &amp;Fn(_))</code>: so users of
higher-order functions can choose which trade-off they want themselves.</p>

<p>All of this flexibility falls directly out of using traits<sup id="fnref:stdfunction" role="doc-noteref"><a href="#fn:stdfunction" class="footnote" rel="footnote">7</a></sup> for
closures, and the separate parts are independent and very
compositional.</p>

<p>The power closures offer allow one to build high-level, “fluent” APIs
without losing performance compared to writing out the details by
hand. The prime example of this is
<a href="http://doc.rust-lang.org/std/iter">iterators</a>: one can write long
chains of calls to adapters like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code> which get
optimised down to efficient C-like code. (For example, I wrote
<a href="/blog/2014/06/comparing-knn-in-rust/">a post</a> that demonstrates this, and the situation has only
improved since then: the closure design described here was implemented
months later.)</p>

<h2 id="in-closing">In closing</h2>

<p>Rust’s C++11-inspired closures are powerful tools that allow for
high-level and efficient code to be build, marrying two properties
often in contention. The moving parts of Rust’s closures are built
directly from the normal type system with traits, structs and
generics, which allows them to automatically gain features like heap
allocation and dynamic dispatch, but doesn’t require them.</p>

<p>(Thanks to Steve Klabnik and Aaron Turon for providing feedback on a
draft, and many commenters on <a href="http://www.reddit.com/r/rust/comments/359tj5/finding_closure_in_rust/">/r/rust</a>
and on IRC for finding inaccuracies and improvements.)</p>

<section id="external-links" class="no-print">
  
  <div id="comments">
    <span class="external-label">Comments:</span>
    <ul class="external-list">
      
<li class="external-link"><a href="https://users.rust-lang.org/t/finding-closure-in-rust/1285">users</a></li>


      
<li class="external-link"><a href="http://www.reddit.com/r/rust/comments/359tj5/finding_closure_in_rust/">/r/rust</a></li>


      

      

      

      
    </ul>
  </div>
  
  <div id="external-page">
    <span class="external-label">Share this on</span>
    <ul class="external-list">
      <li class="external-link"><a href="https://bsky.app/intent/compose?text=Finding%20Closure%20in%20Rust%20by%20@huonw.bsky.social%20https://huonw.github.io/blog/2015/05/finding-closure-in-rust/" target="_blank" rel="nofollow noopener" title="Share on Bluesky">Bluesky</a></li>
      <li class="external-link"><a href="https://twitter.com/intent/tweet?text=Finding%20Closure%20in%20Rust%20%23rustlang&amp;url=https://huonw.github.io/blog/2015/05/finding-closure-in-rust/&amp;via=huon_w" target="_blank" rel="nofollow noopener" title="Share on Twitter">Twitter</a></li>
      <li class="external-link"><a href="https://facebook.com/sharer.php?u=https://huonw.github.io/blog/2015/05/finding-closure-in-rust/" rel="nofollow noopener" target="_blank" title="Share on Facebook">Facebook</a></li>
      <li class="external-link"><a href="https://www.reddit.com/submit?url=https://huonw.github.io/blog/2015/05/finding-closure-in-rust/&amp;title=Finding%20Closure%20in%20Rust" rel="nofollow noopener" target="_blank" title="Share on Reddit">Reddit</a></li>
    </ul>
  </div>
</section>

<div class="footnotes" role="doc-endnotes">
  <ol start="0">
    <li id="fn:anon" role="doc-endnote">
      <p>The Rust <code class="language-plaintext highlighter-rouge">|...| ...</code> syntax is more than just a closure: it’s
     an <a href="http://en.wikipedia.org/wiki/Anonymous_function">anonymous function</a>. In general, it’s possible to have things
     that are closures but aren’t anonymous (e.g. in Python,
     functions declared with <code class="language-plaintext highlighter-rouge">def foo():</code> are closures too, they
     can refer to variables in any scopes in which the <code class="language-plaintext highlighter-rouge">def foo</code>
     is contained). The anonymity refers to the fact that the
     closure expression is a value, it’s possible to just use it
     directly and there’s no separate <code class="language-plaintext highlighter-rouge">fn foo() { ... }</code> with the
     function value referred to via <code class="language-plaintext highlighter-rouge">foo</code>. <a href="#fnref:anon" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:assoc-vs-not" role="doc-endnote">
      <p>This choice is saying that transformers can be
             overloaded by the starting type, but the ending type
             is entirely determined by the pair of the transform
             and the starting type. Using an associated type for
             the return value is more restrictive (no overloading
             on return type only) but it gives the compiler a much
             easier time when inferring types. Using an associated
             type for the input value too would be too
             restrictive: it is very useful for the output type to
             depend on the input type, e.g. a transformation <code class="language-plaintext highlighter-rouge">&amp;'a
             [i32]</code> to <code class="language-plaintext highlighter-rouge">&amp;'a i32</code> (by e.g. indexing) has the two
             types connected via the generic lifetime <code class="language-plaintext highlighter-rouge">'a</code>. <a href="#fnref:assoc-vs-not" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:i-think" role="doc-endnote">
      <p>This statement isn’t precisely true in practice,
        e.g. <code class="language-plaintext highlighter-rouge">rustc</code> will emit different errors if closures are
        misused in certain equivalent-but-non-identical
        ways. However, I believe these are just improved
        diagnostics, not a fundamental language thing… however,
        I’m not sure. <a href="#fnref:i-think" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:copy" role="doc-endnote">
      <p>“By-value” in C++, including <code class="language-plaintext highlighter-rouge">[=]</code>, is really “by-copy” (with
      some copy-elision rules to sometimes elide copies in certain
      cases), whereas in Rust it is always “by-move”, more similar
      to rvalue references in C++. <a href="#fnref:copy" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:trait-object" role="doc-endnote">
      <p>Since closure types are unique and unnameable, the
             only way to return one is via a trait object, at
             least until Rust gets something like the “abstract
             return types” of <a href="https://github.com/rust-lang/rfcs/pull/105">RFC 105</a>, something much
             desired for handling closures. This is a little like
             an interface-checked version of C++11’s
             <code class="language-plaintext highlighter-rouge">decltype(auto)</code>, which, I believe, was also partly
             motivated by closures with unnameable types. <a href="#fnref:trait-object" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:invalid" role="doc-endnote">
      <p>I wrote an invalid <code class="language-plaintext highlighter-rouge">Fn</code> implementation because the real
        version is ugly and much less clear, and doesn’t work with
        stable compilers at the moment. But since you asked, here
        is what’s required:</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#![feature(unboxed_closures, core)]

impl Fn&lt;(i32,)&gt; for Closure {
    extern "rust-call" fn call(&amp;self, (y,): (i32,)) -&gt; i32 {
        self.x + y
    }
}
impl FnMut&lt;(i32,)&gt; for Closure {
    extern "rust-call" fn call_mut(&amp;mut self, args: (i32,)) -&gt; i32 {
        self.call(args)
    }
}
impl FnOnce&lt;(i32,)&gt; for Closure {
    type Output = i32;
    extern "rust-call" fn call_once(self, args: (i32,)) -&gt; i32 {
        self.call(args)
    }
}
</code></pre></div>      </div>

      <p>Just looking at that, one might be able to guess at a few of the
reasons that manual implementations of the function traits aren’t
stabilised for general use. The only way to create types
implementing those traits with the 1.0 compiler is with a closure
expression. <a href="#fnref:invalid" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:inherit" role="doc-endnote">
      <p>I’m ignoring the inheritance, which means that certain
        sets are actually statically illegal, i.e., without other
        constraints there are seven possibilities. <a href="#fnref:inherit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:stdfunction" role="doc-endnote">
      <p>C++ has a similar choice, with <code class="language-plaintext highlighter-rouge">std::function</code> able to
            provide type erasure/dynamic dispatch for closure
            types, although it requires separate definition as a
            library type, and requires allocations. The Rust trait
            objects are a simple building block in the language,
            and don’t require allocations (e.g. <code class="language-plaintext highlighter-rouge">&amp;Fn()</code> is a trait
            object that can be created out of a pointer to the
            stack). <a href="#fnref:stdfunction" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>

    
    <footer id="more" class="no-print">
      <div id="by-line">
  <a href="/about"><div class="no-print" id="me-icon"></div></a>

<p>I'm <a href="https://bsky.app/profile/huonw.bsky.social"><strong>Huon Wilson</strong></a>, a
 mathematically and statistically inclined software engineer.
 I have been a long-term volunteer
 on <a href="http://rust-lang.org">Rust</a>'s core team, a
 compiler engineer on the <a href="https://swift.org/">Swift</a> team
 at Apple, and a senior software engineer at CSIRO's Data61, working on the <a href="https://github.com/stellargraph/stellargraph">StellarGraph
 graph machine learning library</a>.
</p>
</div>
      <h2 id="latest-heading"><a href="/blog">Latest posts</a></h2>
      
      <nav>
        <ul id="latest-list"><!--
           
           --><li class="latest-post">
                <a href="/blog/2024/08/async-hazard-mmap/">
                   <h3>Async hazard: mmap is secretly blocking IO</h3>
                     <p>Memory-mapping a file is convenient, but it’s a hazard when used with async/await concurrent code: it means a “simple” memory index does blocking IO.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2024/07/github-permalinks/">
                   <h3>GitHub tip-hub: habitual permalinks</h3>
                     <p>Hit y to create a permalink to a GitHub directory, file or line. They’re easy to make, stable, and even render a preview in some places.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2024/03/qr-base10-base64/">
                   <h3>10 > 64, in QR codes</h3>
                     <p>QR codes reverse the usual order: decimal works better than base64 for encoding binary data, despite it requiring many more digits.
</p>
                   
                 </a>
            </li><!--
          
      --></ul>
      </nav>
    </footer>
    
  </main>

  <footer id="page-footer">
    <span>Huon Wilson &mdash; <span class="date">2021</span></span>
  </footer>
</div>



<!-- Default Statcounter code for huonw.github.io
http://huonw.github.io -->
<script type="text/javascript">
var sc_project=7439209;
var sc_invisible=1;
var sc_security="b96244c7";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="hit counter"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/7439209/0/b96244c7/1/"
alt="hit counter"
referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
<!-- End of Statcounter Code -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62534856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-62534856-1');
</script>



</body> </html>
