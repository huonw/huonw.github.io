<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>  SIMD in Rust |  Huon on the internet</title>

  <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Atom feed">
  <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RSS feed">
  
  <link rel="canonical" href="https://huonw.github.io/blog/2015/08/simd-in-rust/">

  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  

  
  <meta name="description" content="An overview of my work on improving SIMD in Rust.
" />

  
  <meta name="twitter:card" content="summary" />
  
  <meta name="twitter:site" content="@huon_w" />
  <meta name="twitter:title" content="SIMD in Rust" />
  <meta name="twitter:description" content="An overview of my work on improving SIMD in Rust.
" />
  <meta name="twitter:url" content="https://huonw.github.io/blog/2015/08/simd-in-rust/">

  <!-- facebook -->
  <meta property="og:url" content="https://huonw.github.io/blog/2015/08/simd-in-rust/" />
  <meta property="og:title" content="SIMD in Rust" />
  <meta property="og:description" content="An overview of my work on improving SIMD in Rust.
" />
  
  <meta property="og:type" content="article" />
  
  
  
  <style>
    /*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}html{line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0;font-family:system-ui, -apple-system,'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type='button'],[type='reset'],[type='submit'],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}


    
      /* Borrowed from mojombo: https://github.com/mojombo/mojombo.github.com/blob/master/css/syntax.css */

.lineno { width: 2em; text-align:right; }
.highlight pre {
  white-space: pre;
}
.highlight .c { color: #777; font-style: italic; } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */


html {
    min-height:100%;
}

* {
  margin: 0;
}
* + * {
  margin-top: 0.75em;
}


body {
  padding:0px;
    counter-reset: footnotes;
    counter-reset: figure;
    margin:0px;
    font-size: 18px;
    background: white;
    color: #101010;

    font-variant: common-ligatures;
    -moz-font-feature-settings: "kern" on;
    -webkit-font-feature-settings: "kern" on;
    font-feature-settings: "kern" on;
}

#wrapper {
    margin: 0 auto;
    max-width: 630px;
    padding: 0.75em 15px;
    width: 100%;
    position:relative;
}

.lazily-filled {
  position: relative;
}
.lazily-filled > * {
  z-index: 0;
}
.lazily-filled::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgb(229, 236, 246);
  z-index: 1;
}
.lazily-filled::after {
  position: absolute;
  top: 50%;
  left: 50%;
  content: "";
  display: block;
  width: 128px;
  height: 128px;
  margin-left: -64px;
  margin-top: -64px;
  border-radius: 50%;
  border: 12px solid;
  border-color: white transparent;
  animation: spinner 5s linear;
  /* eventually stop animating when it's hidden */
  animation-iteration-count: 10;
  z-index: 2;
}
.lazily-filled::before, .lazily-filled::after {
  opacity: 0;
  transition: all 0.5s ease;
  pointer-events: none;
}
.lazily-filled:empty::before, .lazily-filled:empty::after {
  opacity: 1;
  animation-iteration-count: infinite;
  visibility: visible;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.plotly-plot * + * {
  margin-top: 0;
}

/* wonky safari */
.plotly text[style*="white-space: pre"] {
  white-space: nowrap !important;
}


/* lists */
li + li {
  margin-top: 0.5em;
}
ul, ol {
  padding-left: 1.5em;
}

table {
  margin-left: auto;
  margin-right: auto;
  border-collapse: collapse;
  text-align: left;
}

td, th {
  padding: 0.1em 0.75em;
}
@media (max-width: 500px) {
  td, th {
    padding-left: 0.375em;
    padding-right: 0.375em;
  }
}
tr:nth-child(even) {
  background: rgba(0, 0, 0, 5%);
}
thead {
  border-bottom: 1px solid grey;
  font-weight: bold;
}

header {
  margin-bottom: 1.5em;
}
header a:not(:hover) {
  text-decoration: none;
}
#blog-title {
  hyphens: none;
  font-variant: small-caps;
  font-size: 1.5em;
  font-weight: normal;
  text-align: center;
  line-height: 1em;
}
#info-list {
  list-style: none;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
}
#info-list li {
  margin: 0 1em;
}

#page-footer {
  border-top: 1px solid lightgrey;
  padding-top: 0.75em;
  color: grey;
  text-align: right;
}

.clear { clear: both; margin: 0; }


main {
    text-align:justify;
    -moz-hyphens: auto;
    -webkit-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
    line-height: 1.5em;

    position: relative;
    z-index: 10;
}

a[href] {
    color: inherit;
    text-decoration: underline;
}

/*  The authorship info */
#info-intro {
    font-style: italic;
    text-align: center;
}

/* code */

code, pre {
  font-family: monospace;
  font-variant: none;
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre {
  background: #f0f0f0;
}
code {
    background: #f7f7f7;
    padding: 0 0.1em;
    font-size: 0.9em;
    border-radius: 3px;
    border: 1px solid lightgrey;
}
pre code {
    background: none;
    padding: 0;
    -moz-hyphens: none;
    -webkit-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    border-radius: 0;
    border-width: 0;
}
h1 code, h2 code, h3 code, h4 code {
  background: rgba(255,255,255,0.1);
}

.break-all {
  word-break: break-all;
}

/* quotes and similar */

blockquote {
    border: solid #eee;
    border-width: 0 1px;
    padding: 0 1.2em;
    color: #444;
    position: relative;
    margin-left: 0;
    margin-right: 0;
}

aside {
  padding: 0 1.2em;
  color: #444;
  position: relative;
}
aside[data-icon] {
  padding-left: 2.4em;
}
aside[data-icon]:before {
  content: attr(data-icon);
  position: absolute;
  left: 0;
  text-align: center;
  width: 2.4em;
}

/* images/figures */
img, figure svg {
  max-width: 100%;
  height: auto;
}
figure svg {
  width: 100%;
}
img:not(.inline-image), figure svg {
    display: block;
    margin: 0 auto;
    clear: both;
}

.image-positioner {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

img[data-caption]:before {
    content: attr(data-caption);
}
figure {
  clear: both;
}
figure.image {
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;

  min-width: 100%;
}
figcaption {
  margin: 0 auto;
  max-width: 570px;
  padding: 0 10px;
  text-align: center;
  font-style: italic;
  font-size: 0.9em;
}
figcaption p {
  display: inline;
}
figcaption::before {
  counter-increment: figure;
  content: "Figure " counter(figure) ". ";
}

.highlight table {
  font-size: 0.9em;
  padding: 0em;
  width: 100%;
  table-layout: fixed;
  overflow-y: hidden;
  display: block;
  position: relative;
  z-index: 1;
}
[data-lang] {
  position: relative;
  display: block;
}
[data-lang]::before {
  content: attr(data-lang);
  text-transform: capitalize;
  top: 0;
  right: 0;
  position: absolute;
  font-size: 1.5em;
  color: #f3f3f3;
  z-index: 1;
}

.highlight pre {
  background: transparent;
}
.gutter {
  padding: 0;
  border: solid #ccc;
  border-width: 0 1px 0 0;
  color: #ccc;
}
.lineno {
  width: 25px;
  padding-right: 5px;
}
.highlight td.code {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}


/* HEADINGS */

h1, h2 {
    font-variant: small-caps;
}

h1, h2, h3, h4 {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
  text-align: left;
}

h1 {
  font-size: 2.2em;
  text-align: center;
  line-height: 1em;
}
h2 {
  font-size: 1.7em;
}
h3 {
  font-size: 1.4em;
}
h4 {
  font-size: 1.2em;
}

/* crates.io badges */

.lib-info {
  float: right;
  width: 150px;
  text-align: center;
  margin: 0 1em;
}
.lib-badge {
  vertical-align: middle;
}
.centered-libs {
  text-align: center;
}
.centered-libs .lib-info {
  float: none;
}

/* external links */

#external-links {
  margin-top: 2.25em;
  text-align: center;
}
.external-label {
  font-weight: bold;
}
#external-links ul {
  list-style: none;
  display: inline-block;
  padding: 0;
  margin: 0;
}
#external-links li {
  list-style: none;
  display: inline;
}

/* "Footnotes" */

/* the div that holds them */
.footnotes {
    margin-top: 2.25em;
    padding-top: 1.5em;
    border-top: 1px solid rgb(240,240,240);
    font-size: 0.9em;
}
.footnotes ol {
  padding: 0;
}
.footnotes li {
    list-style-position: outside;
    margin-left: 30px;
    margin-right: 10px;
    color: #333;
}

.footnotes li:target, .footnotes li:hover {
    color: black;
    background-color: lightyellow;
}

.footnotes .reversefootnote {
    text-decoration: none;
}

/* extra info after a post */
#more {
  margin-top: 3em;
  padding-top: 1.5em;
  border-top: 1px solid lightgray;
}
#me-icon {
  max-width: 150px;
  height: 150px;
  background: url("/img/me.jpg");
  background-size: cover;
  margin-left: auto;
  margin-right: auto;
  border-radius: 30px;
}
#by-line {
  font-size: 0.8em;
}
#latest-list {
  padding: 0;
  list-style: none;
}
#latest-heading {
  text-align: center;
}
#latest-heading a:not(:hover) {
  text-decoration: none;
}
#latest-list a:hover h3 {
  text-decoration: underline;
}
#latest-list a {
  text-decoration: none;
}
.latest-post {
  padding: 0;
  font-size: 0.8em;
}
.latest-post > h3 {
  font-weight: bold;
}
.latest-post * {
  margin: 0;
}

/* post series */

.post-series {
  font-size: 0.8em;
  border: 1px solid lightgray;
  padding: 0.2em;
  cursor: pointer;
}

.post-series-title {
  font-weight: bold;
  font-size: 1.1em;
}
.post-series-list {
  padding-left: 1.5em;
  margin: 0;
}
.post-series .current {
  font-style: italic;
}

/* archive pages */
ul.post-list {
  list-style: none;
  padding: 0;
}

.post-post {
  margin: 0;
}

.post-post + .post-post {
  border-top: 1px dashed  #ddd;
  margin-top: 1em;
  padding-top: 1em;
}

a.post-heading {
  display: flex;
  align-items: baseline;
  text-decoration: none;
  gap: 1em;
}
.post-heading * {
  margin: 0;
}

.post-title {
  font-size: 1.2em;
  flex-grow: 1;
  text-decoration: underline;
}

.post-heading .post-date {
  font-style: italic;
  flex-shrink: 0;
}

.post-excerpt p {
  display: inline;
}

.post-more {
  font-style: italic;
  white-space: nowrap;
  float: right;
  margin: 0;
  font-size: smaller;
}

.post-list .footnote, .post-list .footnotes, .post-list p:empty {
  display: none
}

/* media queries */


@media only print {
    a {
      text-decoration: none !important;
    }
    header {
        display:none !important;
    }

    h1, h2, h3, h4 {
        padding-left: 0 !important;
    }

    #wrapper {
       max-width: none !important;
    }

    .no-print {
        display: none !important;
    }

    .footnotes .reversefootnote {
         display: none !important;
    }
    [data-lang]::before {
      content: "";
    }
}

    

    
  </style>
  
</head>

<body>
<div id="wrapper">
  <header>
    <h1 id="blog-title"><a href="/">Huon on the internet</a></h1>
    <nav>
      <ul id="info-list" class="no-print">
        <li><a href="/about">About</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="https://github.com/huonw">GitHub</a></li>
        <li><a href="https://twitter.com/huon_w">Twitter</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
      
        <h1 id="title"> SIMD in Rust</h1>
        
      
      
         <div id="info-intro">
           By <a href="/about">Huon Wilson</a>
           
             &mdash; <span class="date pub-date">24 Aug 2015</span>
           
           
         </div>
      
      <p>A new scheme for SIMD in <a href="https://www.rust-lang.org/">Rust</a> is available in the latest nightly
compilers, fresh off the builders (get it while it’s hot!).</p>

<p>For the last two months, I’ve been interning at Mozilla Research,
working on improving the state of <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> parallelism in <a href="https://www.rust-lang.org/">Rust</a>:
exposing more CPU instructions in the compiler, and an
<a href="https://github.com/huonw/simd">in-progress library</a> that provides a mostly-safe but
low-level interface to that core functionality.</p>

<p>It’s still simple to use; the following are kernels for rendering
<a href="https://en.wikipedia.org/wiki/Mandelbrot_set">the Mandelbrot set</a>, one scalar, one with explicit
vectorisation, and both similar:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="c">// Scalar!</span>
<span class="c">// compute the escape time for the point `c_x + i c_y`</span>
<span class="k">fn</span> <span class="nf">mandelbrot_naive</span><span class="p">(</span><span class="n">c_x</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">c_y</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c_x</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="n">c_y</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_iter</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">xy</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="mf">4.0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">c_x</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">c_y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">count</span>
<span class="p">}</span>

<span class="c">// SIMD!</span>
<span class="c">// compute the escape time for the four point `c_x + i c_y` at once</span>
<span class="k">fn</span> <span class="nf">mandelbrot_vector</span><span class="p">(</span><span class="n">c_x</span><span class="p">:</span> <span class="n">f32x4</span><span class="p">,</span> <span class="n">c_y</span><span class="p">:</span> <span class="n">f32x4</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">u32x4</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c_x</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="n">c_y</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="nn">u32x4</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">max_iter</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">xy</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">sum</span><span class="nf">.lt</span><span class="p">(</span><span class="nn">f32x4</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">mask</span><span class="nf">.any</span><span class="p">()</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">mask</span><span class="nf">.to_i</span><span class="p">()</span><span class="nf">.select</span><span class="p">(</span><span class="nn">u32x4</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                           <span class="nn">u32x4</span><span class="p">::</span><span class="nf">splat</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">c_x</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">c_y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">count</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<figure class="image has-caption">
  <div class="image-positioner">
    
    <a href="mandel.png">
      <img src="mandel.png" alt="a rendering of the Mandelbrot set" />
    </a>
    
  </div>
  <figcaption><p>The result of both Mandelbrot kernels, running in a loop with some printing code.</p>
</figcaption>
</figure>

<h2 id="simd">SIMD?</h2>

<p>SIMD (Single Instruction Multiple Data) is a way to get data
parallelism on a lot of modern hardware: CPUs have instructions that
will operate on vectors of multiple values in a single call, e.g. most
x86 CPUs offer the <code class="language-plaintext highlighter-rouge">addps</code> and <code class="language-plaintext highlighter-rouge">mulps</code> instructions to do four
single-precision floating point additions (multiplications,
respectively) in parallel, by operating on two 128-bit registers.</p>

<figure class="image ">
  <div class="image-positioner">
    
    <a href="vector.png">
      <img src="vector.png" alt="a diagram of a vector (x + y) * z, where each operand contains four values" />
    </a>
    
  </div>
  
</figure>

<p>Rust is a good fit for many of the headline examples of such
applications, which are traditionally written in C/C++ (or Fortran,
for the last),</p>

<ul>
  <li>media codecs (audio, video, images)</li>
  <li>games/things that do a lot of 3D graphics manipulation</li>
  <li>numerical software (data processing (big or not), simulations etc.)</li>
</ul>

<p>Improved support for explicit SIMD enables Rust to reliably push
hardware to its limit in these areas, and more.</p>

<h2 id="common-vs-platform-specific">Common vs. Platform-specific</h2>

<p>There’s a common core of operations that is widely supported, however,
there is a variety of useful instructions that aren’t found
everywhere. My <code class="language-plaintext highlighter-rouge">simd</code> crate tries to provide a consistent API for the
cross-platform functionality, and then opt-ins for platform specific
things. The cross-platform API of <code class="language-plaintext highlighter-rouge">simd</code> is based on
<a href="https://01.org/node/1495">work on SIMD in JavaScript</a>: they’ve already done the hard
yards to abstract out a basic set of operations that generally work
efficiently, or are extremely useful, everywhere. It definitely
doesn’t cover everything, but it does go a long way.</p>

<p>A limited-but-increasing amount of the platform-specific functionality
is exposed via submodules of the <code class="language-plaintext highlighter-rouge">simd</code> crate, allowing one to opt-in
to non-portability in a manner similar to <a href="http://doc.rust-lang.org/std/os/"><code class="language-plaintext highlighter-rouge">std::os</code></a>. For
example, the SSSE3 instruction <code class="language-plaintext highlighter-rouge">pshufb</code> is exposed as the
<code class="language-plaintext highlighter-rouge">shuffle_bytes</code> method on traits in <code class="language-plaintext highlighter-rouge">simd::x86::ssse3</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">shuffle</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">u8x16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">u8x16</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">u8x16</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">simd</span><span class="p">::</span><span class="nn">x86</span><span class="p">::</span><span class="nn">ssse3</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="n">x</span><span class="nf">.shuffle_bytes</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Caveat Programmor: even the cross-platform API isn’t entirely portable
at the moment, it requires <em>some</em> level of SIMD support in hardware,
and requires the <code class="language-plaintext highlighter-rouge">simd</code> library to have support for the platform. The
major example of this is ARM and i686 (i.e. x86) CPUs aren’t
guaranteed to have SIMD instructions, so one must opt-in via the <code class="language-plaintext highlighter-rouge">-C
target-feature=+neon</code> (respectively <code class="language-plaintext highlighter-rouge">-C target-feature=+sse2</code>)
argument to the compiler<sup id="fnref:cargo" role="doc-noteref"><a href="#fn:cargo" class="footnote" rel="footnote">0</a></sup>. Also, I haven’t worked on PowerPC or
MIPS, focusing only on x86, ARM and AArch64 (ARMv8-A’s 64-bit
architecture).</p>

<h2 id="benchmarks">Benchmarks</h2>

<p>Does this help? Yes! SIMD code in Rust can be several times faster
than scalar code, and is comparable and even ahead of using the
intrinsics in Clang. GCC seems to still have a significant edge over
Rust/LLVM (<code class="language-plaintext highlighter-rouge">rustc</code>’s optimiser) in some cases, but not in others.</p>

<p>I wrote a collection of microbenchmarks comparing the new SIMD
functionality to scalar Rust code, and to similar implementations in
C/C++:</p>

<ul>
  <li>operations on 4×4 <code class="language-plaintext highlighter-rouge">f32</code> matrices (only SIMD Rust vs. scalar Rust)
    <ul>
      <li>inversion</li>
      <li>multiplication</li>
      <li>transposition</li>
    </ul>
  </li>
  <li>the Mandelbrot example above</li>
  <li>some benchmarks from <a href="http://benchmarksgame.alioth.debian.org/">the Benchmark Game</a>, where the fastest
programs use explicit SIMD:
    <ul>
      <li><a href="http://benchmarksgame.alioth.debian.org/u64/performance.php?test=nbody">nbody</a> (fastest on single-core x86-64 is C)</li>
      <li><a href="http://benchmarksgame.alioth.debian.org/u64/performance.php?test=fannkuchredux">fannkuch-redux</a> (C++)</li>
      <li><a href="http://benchmarksgame.alioth.debian.org/u64/performance.php?test=spectralnorm">spectral-norm</a> (C)</li>
    </ul>
  </li>
</ul>

<p>I adapted the inverse and multiply comparative benchmarks from
<a href="https://github.com/tc39/ecmascript_simd/tree/7270420f2f4bd337985307fc46a627c94bd1059e/src/benchmarks">ecmascript_js</a> into Rust microbenchmarks, and
translated the fastest benchmark game programs into Rust. I used the
original implementations of those fastest programs for comparison and
the fastest Rust programs (none of which use explicit SIMD) as a
baseline, after disabling threading. All of this Rust code is
included as <a href="https://github.com/huonw/simd/tree/master/examples">examples</a> or <a href="https://github.com/huonw/simd/tree/master/benches">benchmarks</a> in
the <code class="language-plaintext highlighter-rouge">simd</code> repository.</p>

<p>The Rust code is quite portable. The matrix operations use only the
cross-platform API and so work on x86, ARM and AArch64 right now. The
nbody and spectral-norm benchmarks require <code class="language-plaintext highlighter-rouge">f64</code>s (aka <code class="language-plaintext highlighter-rouge">double</code>s)
which are only supported by x86-64 &amp; AArch64 hardware. The
fannkuch-redux benchmark requires conditionally defining a single
operation based on the platform, which takes only a few lines on each
listed platform.</p>

<figure class="image has-caption">
  <div class="image-positioner">
    
    <a href="chart-x86-64.png">
      <img src="chart-x86-64.png" alt="A chart for x86-64 of the speed-up over scalar code for vectorised code compiled with Rust, Clang and GCC on 3 benchmarks (nbody, spectral-norm, fannkuch-redux), and Rust only for 4 more (matrix inverse, matrix multiply, matrix transpose, mandelbrot). The speed-up ranges from about 1.2 for nbody to about 3 for matrix multiply and mandelbrot." />
    </a>
    
  </div>
  <figcaption><p>Benchmarks on x86-64 (Intel i7-4900MQ). The Rust code was compiled with <code class="language-plaintext highlighter-rouge">-C opt-level=3</code>, the C/C++ with <code class="language-plaintext highlighter-rouge">-O3</code>. SSSE3 was enabled for fannkuch-redux only.</p>
</figcaption>
</figure>

<figure class="image has-caption">
  <div class="image-positioner">
    
    <a href="chart-aarch64.png">
      <img src="chart-aarch64.png" alt="A chart for AArch64 of the speed-up over scalar code for vectorised code compiled with Rust for the same 7 benchmarks (nbody, spectral-norm, fannkuch-redux, matrix inverse, matrix multiply, matrix transpose, mandelbrot). The speed-up ranges from 1 for spectral-norm to about 3.2 for matrix multiply and mandelbrot" />
    </a>
    
  </div>
  <figcaption><p>Benchmarks on AArch64 (Google Nexus 9). The Rust code was compiled with <code class="language-plaintext highlighter-rouge">-C opt-level=3</code>.</p>
</figcaption>
</figure>

<figure class="image has-caption">
  <div class="image-positioner">
    
    <a href="chart-arm.png">
      <img src="chart-arm.png" alt="A chart for ARM of the speed-up over scalar code for vectorised code compiled with Rust for a subset of 5 benchmarks (fannkuch-redux, matrix inverse, matrix multiply, matrix transpose, mandelbrot). The speed-up ranges from 1.8 for fannkuch-redux to 4 for matrix multiply" />
    </a>
    
  </div>
  <figcaption><p>Benchmarks on ARM (Google Nexus 5). The Rust code was compiled with <code class="language-plaintext highlighter-rouge">-C opt-level=3 -C target-feature=+neon</code>.</p>
</figcaption>
</figure>

<p>Compiler versions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rustc 1.4.0-dev (02e97342c 2015-08-17)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Ubuntu clang version 3.6.0-2ubuntu1 (tags/RELEASE_360/final) (based on LLVM 3.6.0)</code></li>
  <li><code class="language-plaintext highlighter-rouge">gcc (Ubuntu 4.9.2-10ubuntu13) 4.9.2</code></li>
</ul>

<h2 id="explicit-simd-in-the-compiler">Explicit SIMD in the Compiler</h2>

<p>My changes are a large incremental improvement over the old SIMD
support in Rust. Previously, the only explicit SIMD supported by the
compiler was declaring types as SIMD vectors with the <code class="language-plaintext highlighter-rouge">#[simd]</code>
attribute, which automatically allowed the use of built-in operators
like <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">*</code> and (sometimes) <code class="language-plaintext highlighter-rouge">==</code>. This was the full extent, and
the only way to get anything beyond that was by relying on the
optimiser, using inline assembly or <a href="http://huonw.github.io/llvmint/llvmint/">horrible hacks</a>. Now,
there are a large number of intrinsics defined by the compiler as
foreign functions with a special ABI. The <code class="language-plaintext highlighter-rouge">simd</code> crate imports them to
implement its functionality, e.g.:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nd">#[repr(simd)]</span>
<span class="k">struct</span> <span class="nf">u8x16</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span>
             <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">);</span>

<span class="k">extern</span> <span class="s">"platform-intrinsic"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">x86_mm_shuffle_epi8</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">u8x16</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">u8x16</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">u8x16</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These intrinsics follow the pattern of
<code class="language-plaintext highlighter-rouge">&lt;architecture&gt;_&lt;vendor's-name&gt;</code>, relying on the definitions that CPU
vendors give.</p>

<p>Speaking of the optimiser, <code class="language-plaintext highlighter-rouge">rustc</code> uses LLVM, which is industrial
strength, and supports a lot of autovectorisation<sup id="fnref:ispc" role="doc-noteref"><a href="#fn:ispc" class="footnote" rel="footnote">1</a></sup>: compiling
scalar code into code that uses SIMD intrinsics. The power of this can
be seen above in the spectral-norm benchmark on AArch64, where the
optimiser managed to make the scalar code just as efficient as the
vector code. However, this is limited: small code changes can disturb
vectorisation optimisations, and, more significantly, vectorisation
may require changing the semantics slightly, and, synthesising
complicated vector instructions is hard for a compiler<sup id="fnref:soa" role="doc-noteref"><a href="#fn:soa" class="footnote" rel="footnote">2</a></sup>.</p>

<p>The new compiler intrinsics brings Rust essentially on par with the
SIMD extensions in C and C++ compilers like GCC, Clang and ICC. It
requires some more manual effort to use it directly, with manual
<code class="language-plaintext highlighter-rouge">extern</code> imports required, but libraries like <code class="language-plaintext highlighter-rouge">simd</code> avoid that issue.</p>

<h2 id="the-future">The Future</h2>

<p>The goal for the immediate future is nailing down the design of the
low-level functionality discussed in <a href="https://github.com/rust-lang/rfcs/pull/1199">RFC 1199</a>, and making
sure that the initial implementation in <a href="https://github.com/rust-lang/rust/pull/27169">#27169</a> matches
that. An unfortunate missing piece is nice support for rearranging
vectors via shuffles and swizzles: I believe it requires
<a href="https://github.com/rust-lang/rfcs/pull/1062">RFC 1062</a> or some other way to have values in generics<sup id="fnref:shuffle" role="doc-noteref"><a href="#fn:shuffle" class="footnote" rel="footnote">3</a></sup>.</p>

<p>My long-term goal is to have <code class="language-plaintext highlighter-rouge">simd</code> provide the common cross-platform
API, with extension traits giving access to all of the
platform-specific instructions. All of this will have as thin an
interface to as possible: the vast majority of functions correspond to
one instruction. (One question I haven’t resolved is what to call
these functions: I could name them directly after the instruction they
correspond to (<code class="language-plaintext highlighter-rouge">pshufb</code>), or after the equivalent C intrinsic
(<code class="language-plaintext highlighter-rouge">_mm_shuffle_epi8</code>), or something approximately descriptive
(<code class="language-plaintext highlighter-rouge">shuffle_bytes</code>). Thoughts?)</p>

<p>I’m not personally planning to build long-vector functionality on top
of the improved short-vector functionality, but it is certainly
something that would be very cool to see.</p>

<p>One major missing piece of this new SIMD support in Rust is how to
handle run-time determination of SIMD functionality: it’s relatively
common to have an algorithm with multiple implementations for
different levels of SIMD support, with a run-time switch to choose the
fastest one supported by the CPU being used. For example, x86-64 CPUs
are only guaranteed to support SSE2, but there’s things beyond that
with more functionality and even longer SIMD vectors (Intel’s new
AVX512 has 512-bit vectors). I’ve got some vague ideas in this area,
but nothing concrete yet.</p>

<section id="external-links" class="no-print">
  
  <div id="comments">
    <span class="external-label">Comments:</span>
    <ul class="external-list">
      
<li class="external-link"><a href="https://users.rust-lang.org/t/improved-simd-in-rust/2604">users</a></li>


      
<li class="external-link"><a href="https://www.reddit.com/r/rust/comments/3i85lg/simd_in_rust/">/r/rust</a></li>


      

      

      
    </ul>
  </div>
  
  <div id="external-page">
    <span class="external-label">Share this on</span>
    <ul class="external-list">
      <li class="external-link"><a href="https://twitter.com/intent/tweet?text=SIMD%20in%20Rust%20%23rustlang&amp;url=https://huonw.github.io/blog/2015/08/simd-in-rust/&amp;via=huon_w" target="_blank" rel="nofollow noopener" title="Share on Twitter">Twitter</a></li>
      <li class="external-link"><a href="https://facebook.com/sharer.php?u=https://huonw.github.io/blog/2015/08/simd-in-rust/" rel="nofollow noopener" target="_blank" title="Share on Facebook">Facebook</a></li>
      <li class="external-link"><a href="https://www.reddit.com/submit?url=https://huonw.github.io/blog/2015/08/simd-in-rust/&amp;title=SIMD%20in%20Rust" rel="nofollow noopener" target="_blank" title="Share on Reddit">Reddit</a></li>
    </ul>
  </div>
</section>

<div class="footnotes" role="doc-endnotes">
  <ol start="0">
    <li id="fn:cargo" role="doc-endnote">
      <p>Passing the <code class="language-plaintext highlighter-rouge">-C target-feature</code> flag to a whole compilation
      with <code class="language-plaintext highlighter-rouge">cargo</code> is somewhat annoying at the moment. It requires
      a custom target spec or intercepting how <code class="language-plaintext highlighter-rouge">rustc</code> is called
      via the <code class="language-plaintext highlighter-rouge">RUSTC</code> environment variable (for my own
      experiments, I’m doing the latter: pointing the variable to
      a shell script that runs <code class="language-plaintext highlighter-rouge">rustc -C target-feature='...'
      "$@"</code>). This is covered by <a href="https://github.com/rust-lang/cargo/issues/1137">#1137</a>. <a href="#fnref:cargo" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ispc" role="doc-endnote">
      <p>LLVM by itself isn’t as powerful as <a href="https://ispc.github.io/">Intel’s ISPC</a>,
     which has its own C variant, but I could imagine a Rust
     version too, to push the limits of compiler-driven
     autovectorisation (among other things) here too. <a href="#fnref:ispc" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:soa" role="doc-endnote">
      <p>Another thing compilers can’t easily do is layout
    optimisations. A major one is an AoS (array-of-structs) to SoA
    (struct-of-arrays) transformation, which is particularly
    important for SIMD, both explicit and autovectorised. <a href="#fnref:soa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:shuffle" role="doc-endnote">
      <p>Fortunately, not all is lost: I’ve always seen the
        optimiser synthesise a real shuffle from a manual series
        of <code class="language-plaintext highlighter-rouge">extract</code>s and a <code class="language-plaintext highlighter-rouge">new</code>. It’s annoying and isn’t
        <em>strictly</em> guaranteed, but it seems to be pretty reliable. <a href="#fnref:shuffle" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>

    
    <footer id="more" class="no-print">
      <div id="by-line">
  <a href="/about"><div class="no-print" id="me-icon"></div></a>

<p>I'm <strong>Huon Wilson</strong> <a href="https://twitter.com/huon_w">@huon_w</a>, a
 mathematically and statistically inclined software engineer.
 I have been a long-term volunteer
 on <a href="http://rust-lang.org">Rust</a>'s core team, a
 compiler engineer on the <a href="https://swift.org/">Swift</a> team
 at Apple, and a senior software engineer at CSIRO's Data61, working on the <a href="https://github.com/stellargraph/stellargraph">StellarGraph
 graph machine learning library</a>.
</p>
</div>
      <h2 id="latest-heading"><a href="/blog">Latest posts</a></h2>
      
      <nav>
        <ul id="latest-list"><!--
           
           --><li class="latest-post">
                <a href="/blog/2024/03/qr-base10-base64/">
                   <h3>10 > 64, in QR codes</h3>
                     <p>QR codes
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2021/10/nsw-covid-qr/">
                   <h3>Mechanical sympathy for QR codes: making NSW check-in better</h3>
                     <p>QR codes are now critical infrastructure here in NSW, Australia. Let’s learn how to make them better.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2021/09/qr-error-correction/">
                   <h3>QR error correction helps and hinders scanning</h3>
                     <p>A QR code can use one of four error correction levels. Higher error correction forces denser codes, but allows scanning in more situations. A trade-off!
</p>
                   
                 </a>
            </li><!--
          
      --></ul>
      </nav>
    </footer>
    
  </main>

  <footer id="page-footer">
    <span>Huon Wilson &mdash; <span class="date">2021</span></span>
  </footer>
</div>



<!-- Default Statcounter code for huonw.github.io
http://huonw.github.io -->
<script type="text/javascript">
var sc_project=7439209;
var sc_invisible=1;
var sc_security="b96244c7";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="hit counter"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/7439209/0/b96244c7/1/"
alt="hit counter"
referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
<!-- End of Statcounter Code -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62534856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-62534856-1');
</script>



</body> </html>
