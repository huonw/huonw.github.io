<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>  Memory Leaks are Memory Safe |  Huon on the internet</title>

  <link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Atom feed">
  <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="RSS feed">
  
  <link rel="canonical" href="https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/">

  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  

  
  <meta name="description" content="Memory unsafety and memory leaks are distinct concepts, despite their names. Languages that are merely memory safe (both Rust and GC-reliant managed ones) have no guarantee of preventing memory leaks.
" />

  
  <meta name="twitter:card" content="summary" />
  
  <meta name="twitter:site" content="@huon_w" />
  <meta name="twitter:title" content="Memory Leaks are Memory Safe" />
  <meta name="twitter:description" content="Memory unsafety and memory leaks are distinct concepts, despite their names. Languages that are merely memory safe (both Rust and GC-reliant managed ones) have no guarantee of preventing memory leaks.
" />
  <meta name="twitter:url" content="https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/">

  <!-- facebook -->
  <meta property="og:url" content="https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/" />
  <meta property="og:title" content="Memory Leaks are Memory Safe" />
  <meta property="og:description" content="Memory unsafety and memory leaks are distinct concepts, despite their names. Languages that are merely memory safe (both Rust and GC-reliant managed ones) have no guarantee of preventing memory leaks.
" />
  
  <meta property="og:type" content="article" />
  
  
  
  <style>
    /*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}html{line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0;font-family:system-ui, -apple-system,'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type='button'],[type='reset'],[type='submit'],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}


    
      /* Borrowed from mojombo: https://github.com/mojombo/mojombo.github.com/blob/master/css/syntax.css */

.lineno { width: 2em; text-align:right; }
.highlight pre {
  white-space: pre;
}
.highlight .c { color: #777; font-style: italic; } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */


html {
    min-height:100%;
}

* {
  margin: 0;
}
* + * {
  margin-top: 0.75em;
}


body {
  padding:0px;
    counter-reset: footnotes;
    counter-reset: figure;
    margin:0px;
    font-size: 18px;
    background: white;
    color: #101010;

    font-variant: common-ligatures;
    -moz-font-feature-settings: "kern" on;
    -webkit-font-feature-settings: "kern" on;
    font-feature-settings: "kern" on;
}

#wrapper {
    margin: 0 auto;
    max-width: 630px;
    padding: 0.75em 15px;
    width: 100%;
    position:relative;
}

.lazily-filled {
  position: relative;
}
.lazily-filled > * {
  z-index: 0;
}
.lazily-filled::before {
  position: absolute;
  top: 0;
  left: 0;
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgb(229, 236, 246);
  z-index: 1;
}
.lazily-filled::after {
  position: absolute;
  top: 50%;
  left: 50%;
  content: "";
  display: block;
  width: 128px;
  height: 128px;
  margin-left: -64px;
  margin-top: -64px;
  border-radius: 50%;
  border: 12px solid;
  border-color: white transparent;
  animation: spinner 5s linear;
  /* eventually stop animating when it's hidden */
  animation-iteration-count: 10;
  z-index: 2;
}
.lazily-filled::before, .lazily-filled::after {
  opacity: 0;
  transition: all 0.5s ease;
  pointer-events: none;
}
.lazily-filled:empty::before, .lazily-filled:empty::after {
  opacity: 1;
  animation-iteration-count: infinite;
  visibility: visible;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.plotly-plot * + * {
  margin-top: 0;
}

/* wonky safari */
.plotly text[style*="white-space: pre"] {
  white-space: nowrap !important;
}


/* lists */
li + li {
  margin-top: 0.5em;
}
ul, ol {
  padding-left: 1.5em;
}

table {
  margin-left: auto;
  margin-right: auto;
  border-collapse: collapse;
  text-align: left;
}

td, th {
  padding: 0.1em 0.75em;
}
@media (max-width: 500px) {
  td, th {
    padding-left: 0.375em;
    padding-right: 0.375em;
  }
}
tr:nth-child(even) {
  background: rgba(0, 0, 0, 5%);
}
thead {
  border-bottom: 1px solid grey;
  font-weight: bold;
}

header {
  margin-bottom: 1.5em;
}
header a:not(:hover) {
  text-decoration: none;
}
#blog-title {
  hyphens: none;
  font-variant: small-caps;
  font-size: 1.5em;
  font-weight: normal;
  text-align: center;
  line-height: 1em;
}
#info-list {
  list-style: none;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
}
#info-list li {
  margin: 0 1em;
}

#page-footer {
  border-top: 1px solid lightgrey;
  padding-top: 0.75em;
  color: grey;
  text-align: right;
}

.clear { clear: both; margin: 0; }


main {
    text-align:justify;
    -moz-hyphens: auto;
    -webkit-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
    line-height: 1.5em;

    position: relative;
    z-index: 10;
}

a[href] {
    color: inherit;
    text-decoration: underline;
}

/*  The authorship info */
#info-intro {
    font-style: italic;
    text-align: center;
}

/* code */

code, pre {
  font-family: monospace;
  font-variant: none;
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre {
  background: #f0f0f0;
}
code {
    background: #f7f7f7;
    padding: 0 0.1em;
    font-size: 0.9em;
    border-radius: 3px;
    border: 1px solid lightgrey;
}
pre code {
    background: none;
    padding: 0;
    -moz-hyphens: none;
    -webkit-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    border-radius: 0;
    border-width: 0;
}
h1 code, h2 code, h3 code, h4 code {
  background: rgba(255,255,255,0.1);
}

.break-all {
  word-break: break-all;
}

/* quotes and similar */

blockquote {
    border: solid #eee;
    border-width: 0 1px;
    padding: 0 1.2em;
    color: #444;
    position: relative;
    margin-left: 0;
    margin-right: 0;
}

aside {
  padding: 0 1.2em;
  color: #444;
  position: relative;
}
aside[data-icon] {
  padding-left: 2.4em;
}
aside[data-icon]:before {
  content: attr(data-icon);
  position: absolute;
  left: 0;
  text-align: center;
  width: 2.4em;
}

/* images/figures */
img, figure svg {
  max-width: 100%;
  height: auto;
}
figure svg {
  width: 100%;
}
img:not(.inline-image), figure svg {
    display: block;
    margin: 0 auto;
    clear: both;
}

.image-positioner {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

img[data-caption]:before {
    content: attr(data-caption);
}
figure {
  clear: both;
}
figure.image {
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;

  min-width: 100%;
}
figcaption {
  margin: 0 auto;
  max-width: 570px;
  padding: 0 10px;
  text-align: center;
  font-style: italic;
  font-size: 0.9em;
}
figcaption p {
  display: inline;
}
figcaption::before {
  counter-increment: figure;
  content: "Figure " counter(figure) ". ";
}

.highlight table {
  font-size: 0.9em;
  padding: 0em;
  width: 100%;
  table-layout: fixed;
  overflow-y: hidden;
  display: block;
  position: relative;
  z-index: 1;
}
[data-lang] {
  position: relative;
  display: block;
}
[data-lang]::before {
  content: attr(data-lang);
  text-transform: capitalize;
  top: 0;
  right: 0;
  position: absolute;
  font-size: 1.5em;
  color: #f3f3f3;
  z-index: 1;
}

.highlight pre {
  background: transparent;
}
.gutter {
  padding: 0;
  border: solid #ccc;
  border-width: 0 1px 0 0;
  color: #ccc;
}
.lineno {
  width: 25px;
  padding-right: 5px;
}
.highlight td.code {
  overflow-x: auto;
  padding: 0;
  padding-left: 0.5em;
}


/* HEADINGS */

h1, h2 {
    font-variant: small-caps;
}

h1, h2, h3, h4 {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
  text-align: left;
}

h1 {
  font-size: 2.2em;
  text-align: center;
  line-height: 1em;
}
h2 {
  font-size: 1.7em;
}
h3 {
  font-size: 1.4em;
}
h4 {
  font-size: 1.2em;
}

/* crates.io badges */

.lib-info {
  float: right;
  width: 150px;
  text-align: center;
  margin: 0 1em;
}
.lib-badge {
  vertical-align: middle;
}
.centered-libs {
  text-align: center;
}
.centered-libs .lib-info {
  float: none;
}

/* external links */

#external-links {
  margin-top: 2.25em;
  text-align: center;
}
.external-label {
  font-weight: bold;
}
#external-links ul {
  list-style: none;
  display: inline-block;
  padding: 0;
  margin: 0;
}
#external-links li {
  list-style: none;
  display: inline;
}

/* "Footnotes" */

/* the div that holds them */
.footnotes {
    margin-top: 2.25em;
    padding-top: 1.5em;
    border-top: 1px solid rgb(240,240,240);
    font-size: 0.9em;
}
.footnotes ol {
  padding: 0;
}
.footnotes li {
    list-style-position: outside;
    margin-left: 30px;
    margin-right: 10px;
    color: #333;
}

.footnotes li:target, .footnotes li:hover {
    color: black;
    background-color: lightyellow;
}

.footnotes .reversefootnote {
    text-decoration: none;
}

/* extra info after a post */
#more {
  margin-top: 3em;
  padding-top: 1.5em;
  border-top: 1px solid lightgray;
}
#me-icon {
  max-width: 150px;
  height: 150px;
  background: url("/img/me.jpg");
  background-size: cover;
  margin-left: auto;
  margin-right: auto;
  border-radius: 30px;
}
#by-line {
  font-size: 0.8em;
}
#latest-list {
  padding: 0;
  list-style: none;
}
#latest-heading {
  text-align: center;
}
#latest-heading a:not(:hover) {
  text-decoration: none;
}
#latest-list a:hover h3 {
  text-decoration: underline;
}
#latest-list a {
  text-decoration: none;
}
.latest-post {
  padding: 0;
  font-size: 0.8em;
}
.latest-post > h3 {
  font-weight: bold;
}
.latest-post * {
  margin: 0;
}

/* post series */

.post-series {
  font-size: 0.8em;
  border: 1px solid lightgray;
  padding: 0.2em;
  cursor: pointer;
}

.post-series-title {
  font-weight: bold;
  font-size: 1.1em;
}
.post-series-list {
  padding-left: 1.5em;
  margin: 0;
}
.post-series .current {
  font-style: italic;
}

/* archive pages */
ul.post-list {
  list-style: none;
  padding: 0;
}

.post-post {
  margin: 0;
}

.post-post + .post-post {
  border-top: 1px dashed  #ddd;
  margin-top: 1em;
  padding-top: 1em;
}

a.post-heading {
  display: flex;
  align-items: baseline;
  text-decoration: none;
  gap: 1em;
}
.post-heading * {
  margin: 0;
}

.post-title {
  font-size: 1.2em;
  flex-grow: 1;
  text-decoration: underline;
}

.post-heading .post-date {
  font-style: italic;
  flex-shrink: 0;
}

.post-excerpt p {
  display: inline;
}

.post-more {
  font-style: italic;
  white-space: nowrap;
  float: right;
  margin: 0;
  font-size: smaller;
}

.post-list .footnote, .post-list .footnotes, .post-list p:empty {
  display: none
}

/* media queries */


@media only print {
    a {
      text-decoration: none !important;
    }
    header {
        display:none !important;
    }

    h1, h2, h3, h4 {
        padding-left: 0 !important;
    }

    #wrapper {
       max-width: none !important;
    }

    .no-print {
        display: none !important;
    }

    .footnotes .reversefootnote {
         display: none !important;
    }
    [data-lang]::before {
      content: "";
    }
}

    

    
  </style>
  
</head>

<body>
<div id="wrapper">
  <header>
    <h1 id="blog-title"><a href="/">Huon on the internet</a></h1>
    <nav>
      <ul id="info-list" class="no-print">
        <li><a href="/about">About</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="https://github.com/huonw">GitHub</a></li>
        <li><a href="https://bsky.app/profile/huonw.bsky.social">Bluesky</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
      
        <h1 id="title"> Memory Leaks are Memory Safe</h1>
        
      
      
         <div id="info-intro">
           By <a href="/about">Huon Wilson</a>
           
             &mdash; <span class="date pub-date">04 Apr 2016</span>
           
           
         </div>
      
      <p><a href="https://en.wikipedia.org/wiki/Memory_safety"><em>Memory unsafety</em></a> and <a href="https://en.wikipedia.org/wiki/Memory_leak"><em>memory leaks</em></a> are arguably the two
categories of bugs that have received the most attention for
prevention and mitigation. As their names suggest, they are in the
same part of ‚Äúbug space‚Äù, however they are in some ways diametric
opposites, and solving one does not solve the other. The widespread
use of memory-safe managed languages hammers this point home: they
avoid some memory unsafety by presenting a ‚Äúleak everything‚Äù model to
programmers.</p>

<p>Put simply: <strong>memory unsafety is doing something with invalid data,
a memory leak is <em>not</em> doing something with valid data</strong>. In table
form:</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>Valid data</th>
      <th>Invalid data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Used</strong></td>
      <td>üëç</td>
      <td>Memory unsafety</td>
    </tr>
    <tr>
      <td><strong>Not used</strong></td>
      <td>Memory leak</td>
      <td>üëç</td>
    </tr>
  </tbody>
</table>

<p>The best programs lie in the üëç cells only: they manipulate valid
things, and don‚Äôt manipulate invalid ones. Passable programs might
also have some valid data that they don‚Äôt use (leak memory), but bad
ones will try to use invalid data.</p>

<p>When a language, such as Rust, advertises itself as memory <em>safe</em>, it
isn‚Äôt saying anything about whether memory <em>leaks</em> are impossible.</p>

<h2 id="consequences">Consequences</h2>

<p>The most important difference between memory unsafety and memory leaks
in practice is the scope of their possible results, with one easily
very serious, and the other usually just annoying.</p>

<p>Memory safety is a key building block in any other form of
safety/program correctness. If a program is not memory safe, there are
very few guarantees about its behaviour, due to the possibility of
memory corruption. A malicious party interacting with a memory unsafe
program may be able to exploit the unsafety to
<a href="https://en.wikipedia.org/wiki/Heartbleed">read private keys straight out of a server‚Äôs memory</a> or
to execute arbitrary code on someone else‚Äôs computer.</p>

<p>On the other hand, a memory leak will generally, at worst, lead to a
denial-of-service, where a useful program is killed due to using too
much memory (and, as it grows to this stage, the computer may be
rendered essentially inoperable due to memory pressure). This also can
be caused by a malicious attacker, but the damage is usually very much
more controlled. Of course, a denial-of-service can be extremely
annoying, and there are places where this is a critical problem, but
memory unsafety would generally be equally problematic‚Äîmore likely,
more problematic. (Additionally, given memory unsafety‚Äôs inherent lack
of control, a problem there could easily lead to a denial-of-service
similar/identical to that which a memory leak can cause.)</p>

<p>Given this, most programming languages choose to tolerate memory leaks
(they allow data not be deallocated/cleaned up after the last time it
is used), but not memory unsafety. That is, most ‚Äúmemory safe
languages‚Äù guarantee all programs written in them have no
unsafety<sup id="fnref:optin"><a href="#fn:optin" class="footnote" rel="footnote" role="doc-noteref">0</a></sup>, and they only try‚Äîusually, try hard‚Äîto help
programmers avoid leaks, but without making a hard promise.</p>

<h2 id="delete-free"><code class="language-plaintext highlighter-rouge">delete free</code></h2>

<p>There are a few different ways to get memory unsafety, but there‚Äôs one
category (from the Wikipedia article) that stands out when we‚Äôre
discussing memory management:</p>

<blockquote>
  <ul>
    <li><strong>Dynamic memory errors</strong> - incorrect management of dynamic memory and pointers:
      <ul>
        <li><strong>Dangling pointer</strong> - a pointer storing the address of an object that has been deleted.</li>
        <li><strong>Double free</strong> - repeated calls to free may prematurely free a new object at the same address. If the exact address has not been reused, other corruption may occur, especially in allocators that use free lists.</li>
        <li><strong>Invalid free</strong> - passing an invalid address to free can corrupt the heap.</li>
        <li><strong>Null pointer accesses</strong> will cause an exception or program termination in most environments, but can cause corruption in operating system kernels or systems without memory protection, or when use of the null pointer involves a large or negative offset.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>In that list, only null pointer accesses aren‚Äôt caused by deallocating
memory‚Äîcalling the <code class="language-plaintext highlighter-rouge">free</code> function to mark an allocation as
unused/return it to the operating system‚Äîincorrectly. And thus, one
way to be guaranteed to avoid three quarters of those possibilities is
to just never call <code class="language-plaintext highlighter-rouge">free</code>: if memory is never released, it is
impossible to suffer from the problems caused by releasing it. In
terms of the table above, removing <code class="language-plaintext highlighter-rouge">free</code> is removing the ‚ÄúInvalid
data‚Äù column: all data is always valid.</p>

<p>Of course, just disallowing <code class="language-plaintext highlighter-rouge">free</code> has some downsides<sup id="fnref:lockfree"><a href="#fn:lockfree" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, particularly
making it very annoying to write programs that don‚Äôt eventually use
all available memory. However, computers are infallible in ways humans
are not, so maybe we could allow them to call <code class="language-plaintext highlighter-rouge">free</code>‚Ä¶</p>

<h2 id="optimising-leaks">Optimising leaks</h2>

<p>A large fraction of modern code is written in languages designed to be
memory safe, languages like Java, Javascript, Python and Ruby. They
have no explicit <code class="language-plaintext highlighter-rouge">free</code>, and so automatically manage memory (hence
‚Äúmanaged language‚Äù) via a <em>garbage collector</em> built into the runtime
systems shipped with the languages‚Äô compilers and interpreters.</p>

<p>At its core<sup id="fnref:layers"><a href="#fn:layers" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, garbage collection is a way to make it feasible
to expose a programming model where all allocations leak. Letting a
garbage collector manage every allocation theoretically allows
programs (and programmers) to pretend that memory is infinite, not
needing to carefully track when memory isn‚Äôt needed any more: programs
do whatever they want, and the GC will automatically and dynamically
free chunks of memory that are guaranteed to be unneeded, ensuring the
program‚Äôs memory use remains under control. Almost all garbage
collectors determine neededness conservatively by finding things no longer
accessible from the main program (the garbage collector itself needs
to keep track of/have access to all allocations).</p>

<p>In practice, the programmer has to think about non-infinite
memory and its consequences a little more often than never, but memory
unsafety concerns <em>are</em> removed, as desired. High-performance code
often has to chose particular coding patterns to work-around
deficiencies with garbage collectors (such as object pools to avoid
touching the GC in tight loops), and one can accidentally create
<a href="https://en.wikipedia.org/wiki/Lapsed_listener_problem">chains of references</a> that keep large trees of data
unnecessarily alive.</p>

<p>However, even in the face of practical concerns, the point stands:
without <code class="language-plaintext highlighter-rouge">free</code>, there‚Äôs no scope for some types of memory unsafety.</p>

<!--(Due credit: I think I first heard an idea along the lines "GC is an
optimisation for leaking" from
[Alexis Beingessner](https://twitter.com/Gankro).)-->

<h2 id="less-leaky-abstractions">Less leaky abstractions</h2>

<p>Given my status, I‚Äôd be remiss to mention an alternative to the
leak-everything managed paradigm: instead using a technique that
crosses out the whole ‚ÄúInvalid data‚Äù column, one can be more precise
and cross out only the ‚ÄúMemory unsafety‚Äù cell. The <a href="https://www.rust-lang.org/">Rust programming language</a> does this.</p>

<p>Rust doesn‚Äôt have C-style manual memory management, but rather
RAII/scope-based resource management similar to C++, allowing types to
have destructors for automatic clean-up. It does not literally have a
<code class="language-plaintext highlighter-rouge">free</code> function users must remember to call (removing most of the
‚Äúmanual‚Äù), but the <a href="http://doc.rust-lang.org/std/mem/fn.drop.html"><code class="language-plaintext highlighter-rouge">drop</code></a> function serves the role of explicit
<code class="language-plaintext highlighter-rouge">free</code>, allowing one to explicitly cause the destructor to be run on a
value, thus invalidating it. In contrast to both C and C++, the
language prevents use of such data at compile time to avoid memory
unsafety.</p>

<p>However, a programming model that‚Äôs not ‚Äúleak everything‚Äù doesn‚Äôt mean
it is ‚Äúleak nothing‚Äù: the revised table for Rust (and anything
similar) still has its memory leak cell.</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>Valid data</th>
      <th>Invalid data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Used</strong></td>
      <td>üëç</td>
      <td>Impossible</td>
    </tr>
    <tr>
      <td><strong>Not used</strong></td>
      <td>Memory leak</td>
      <td>üëç</td>
    </tr>
  </tbody>
</table>

<p>I‚Äôm not including this section because I think it‚Äôs a great promotion
of Rust (being allowed to have invalid data that one can‚Äôt use doesn‚Äôt
exactly sound world-shaking<sup id="fnref:moves"><a href="#fn:moves" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>‚Ä¶), but because that is the hole
which this article is filling. The similarity of the phrases ‚Äúmemory
leak‚Äù and ‚Äúmemory safety‚Äù regularly tricks people who have read ‚ÄúRust
is memory safe‚Äù into thinking Rust is (just) preventing memory leaks,
leading to legitimate doubts about what Rust offers instead of, say,
modern C++ in the space of low-level systems languages.  <strong>Rust
disallows memory unsafety, but memory leaks are possible</strong>.</p>

<h3 id="stdmemforget"><code class="language-plaintext highlighter-rouge">std::mem::forget</code></h3>

<p>Finally, returning to the title, Rust has the <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code class="language-plaintext highlighter-rouge">forget</code></a>
function, which throws away a value without actually running the
destructor while still marking it invalid as if freed normally, thus
possibly leaking memory. For a long time, this was marked as <code class="language-plaintext highlighter-rouge">unsafe</code>,
that is, Rust was implicitly including memory leaks as something the
programmer must opt-in to, like the risk of memory unsafety. However,
this was not correct in practice, as things like reference cycles and
thread deadlock could cause memory to leak. Rust <a href="https://github.com/rust-lang/rfcs/blob/master/text/1066-safe-mem-forget.md">decided</a> to
make <code class="language-plaintext highlighter-rouge">forget</code> safe, focusing its guarantees on just preventing memory
unsafety and instead making only best-effort attempts
towards preventing memory leaks (like essentially all other
languages, memory safe and otherwise).</p>

<h3 id="not-all-is-lost">Not all is lost!</h3>

<p>Like modern C++, the efforts Rust makes are pretty good, with
RAII/scope-based resource management (specifically destructors) being
a powerful tool for managing memory and <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html#locks">beyond</a> (and
<a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">beyonder</a>), especially when combined with Rust‚Äôs
move-by-default semantics. The point about not being a guarantee is
that (a) it‚Äôs not trivial to make a useful <em>formal</em> definition of
memory leak (at the very least, usefulness varies depending on the
context), and (b) there are relatively rare edge-cases that seem to be
impossible to statically prevent without non-trivial cost. The
<a href="http://doc.rust-lang.org/stable/nomicon/leaking.html">wash-up</a> in Rust‚Äôs standard library is all values have to be
<em>memory safe</em> to leak, but they can still consider being leaked
incorrect. In other words, one may get unwanted behaviour if a value
is leaked, but the consequences will be more far controlled than a
segfault or memory corruption.</p>

<section id="external-links" class="no-print">
  
  <div id="comments">
    <span class="external-label">Comments:</span>
    <ul class="external-list">
      
<li class="external-link"><a href="https://users.rust-lang.org/t/memory-leaks-are-memory-safe/5288?u=huon">users</a></li>


      
<li class="external-link"><a href="https://www.reddit.com/r/rust/comments/4dgvvh/memory_leaks_are_memory_safe_huon_on_the_internet/">/r/rust</a></li>


      

      

      

      
    </ul>
  </div>
  
  <div id="external-page">
    <span class="external-label">Share this on</span>
    <ul class="external-list">
      <li class="external-link"><a href="https://bsky.app/intent/compose?text=Memory%20Leaks%20are%20Memory%20Safe%20by%20@huonw.bsky.social%20https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/" target="_blank" rel="nofollow noopener" title="Share on Bluesky">Bluesky</a></li>
      <li class="external-link"><a href="https://twitter.com/intent/tweet?text=Memory%20Leaks%20are%20Memory%20Safe%20%23rustlang&amp;url=https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/&amp;via=huon_w" target="_blank" rel="nofollow noopener" title="Share on Twitter">Twitter</a></li>
      <li class="external-link"><a href="https://facebook.com/sharer.php?u=https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/" rel="nofollow noopener" target="_blank" title="Share on Facebook">Facebook</a></li>
      <li class="external-link"><a href="https://www.reddit.com/submit?url=https://huonw.github.io/blog/2016/04/memory-leaks-are-memory-safe/&amp;title=Memory%20Leaks%20are%20Memory%20Safe" rel="nofollow noopener" target="_blank" title="Share on Reddit">Reddit</a></li>
    </ul>
  </div>
</section>

<div class="footnotes" role="doc-endnotes">
  <ol start="0">
    <li id="fn:optin">
      <p>More specifically, programming languages will guarantee that
one can only get unsafety by explicitly opting in to it, in some
form, such as via Python‚Äôs <code class="language-plaintext highlighter-rouge">ctypes</code> module, or Rust‚Äôs <code class="language-plaintext highlighter-rouge">unsafe</code>
keyword.¬†<a href="#fnref:optin" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:lockfree">
      <p>It also has some upsides beyond just less memory
unsafety: if one is OK without <code class="language-plaintext highlighter-rouge">free</code>, it becomes much easier to
write programs where the lifetime of data is unclear, which makes
many concurrent algorithms easier to write. That said, there are
schemes for writing such code when manual <code class="language-plaintext highlighter-rouge">free</code>s are required,
such as <a href="https://en.wikipedia.org/wiki/Hazard_pointer">hazard pointers</a> and the simpler
<a href="http://aturon.github.io/blog/2015/08/27/epoch/">epoch-based memory reclamation</a>.¬†<a href="#fnref:lockfree" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:layers">
      <p>It‚Äôs worth noting that the detailed knowledge of memory
layout required for a top-flight garbage collectors lends itself
to other tricks, such as allocations usually being a cheap pointer
bump with a generational GC, and the ability for a moving GC to
shift data around, improving cache locality (especially useful
given the generally pointer-heavy nature of most managed
languages). However, these tricks are orthogonal to both memory
safety and memory leaks.¬†<a href="#fnref:layers" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:moves">
      <p>It‚Äôs pretty useful, in that it allows move semantics to
work, but that‚Äôs an article for another time, perhaps.¬†<a href="#fnref:moves" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>

    
    <footer id="more" class="no-print">
      <div id="by-line">
  <a href="/about"><div class="no-print" id="me-icon"></div></a>

<p>I'm <a href="https://bsky.app/profile/huonw.bsky.social"><strong>Huon Wilson</strong></a>, a
 mathematically and statistically inclined software engineer.
 I have been a long-term volunteer
 on <a href="http://rust-lang.org">Rust</a>'s core team, a
 compiler engineer on the <a href="https://swift.org/">Swift</a> team
 at Apple, and a senior software engineer at CSIRO's Data61, working on the <a href="https://github.com/stellargraph/stellargraph">StellarGraph
 graph machine learning library</a>.
</p>
</div>
      <h2 id="latest-heading"><a href="/blog">Latest posts</a></h2>
      
      <nav>
        <ul id="latest-list"><!--
           
           --><li class="latest-post">
                <a href="/blog/2025/04/standalone-shell-script-reproducer/">
                   <h3>Communicating bugs: use a single standalone shell script</h3>
                     <p>When I file a bug, I can get more reliable minimal working examples using a shell script, leading to better bugs and faster help.
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/03/rust-fallthrough/">
                   <h3>Take a break: Rust match has fallthrough</h3>
                     <p>Match + labelled blocks &amp; breaks = fallthrough. It works, but it‚Äôs not very pretty!
</p>
                   
                 </a>
            </li><!--
          
           --><li class="latest-post">
                <a href="/blog/2025/03/ev-newtons/">
                   <h3>Newtons are a unit of mileage</h3>
                     <p>For an EV, Newtons (N) is a seemingly sensible version of L/100km or mpg, for measuring the efficiency of the car. Summing drag and rolling resistance forces aligns closely to real world observations.
</p>
                   
                 </a>
            </li><!--
          
      --></ul>
      </nav>
    </footer>
    
  </main>

  <footer id="page-footer">
    <span>Huon Wilson &mdash; <span class="date">2021</span></span>
  </footer>
</div>



<!-- Default Statcounter code for huonw.github.io
http://huonw.github.io -->
<script type="text/javascript">
var sc_project=7439209;
var sc_invisible=1;
var sc_security="b96244c7";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="hit counter"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/7439209/0/b96244c7/1/"
alt="hit counter"
referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
<!-- End of Statcounter Code -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-62534856-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-62534856-1');
</script>



</body> </html>
